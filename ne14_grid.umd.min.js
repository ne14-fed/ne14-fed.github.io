(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ne_grid = {}));
}(this, (function (exports) { 'use strict';

    class CustomElementBase extends HTMLElement {
        constructor(css, html, mode = 'closed') {
            super();
            this.root = this.attachShadow({ mode });
            this.root.innerHTML = html;
            const style = document.createElement('style');
            style.textContent = css;
            this.root.appendChild(style);
        }
    }

    function decode(b64) {
        const bIndex = (b64 + '').indexOf('base64,');
        return bIndex === -1 ? b64 : window.atob(b64.substring(bIndex + 7));
    }
    function reduceCss(cssIn) {
        return cssIn
            .replace(/\s+/g, ' ')
            .replace(/([,{}:;])\s/g, '$1')
            .replace(/\s([{])/g, '$1');
    }
    function reduceHtml(htmlIn) {
        return htmlIn.replace(/\s+/g, ' ').replace(/(^|>)\s+(<|$)/g, '$1$2');
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var ChainedQuery = /** @class */ (function () {
        function ChainedQuery(mapper) {
            var _this = this;
            var sources = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                sources[_i - 1] = arguments[_i];
            }
            this.mapper = mapper;
            this._items = [];
            this.get = function (index) { return _this._items[index]; };
            this.add.apply(this, sources);
        }
        Object.defineProperty(ChainedQuery.prototype, "targets", {
            get: function () {
                return this._items.filter(function (it) { return it instanceof EventTarget; }).map(function (it) { return it; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChainedQuery.prototype, "elements", {
            get: function () {
                return this._items.filter(function (it) { return it instanceof Element; }).map(function (it) { return it; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChainedQuery.prototype, "nodes", {
            get: function () {
                return this._items.filter(function (it) { return it instanceof Node; }).map(function (it) { return it; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChainedQuery.prototype, "containers", {
            get: function () {
                return this._items.map(function (it) { return it; }).filter(function (p) { return typeof p.append === 'function'; });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChainedQuery.prototype, "length", {
            get: function () {
                return this._items.length;
            },
            enumerable: false,
            configurable: true
        });
        ChainedQuery.prototype.add = function () {
            var _a;
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            (_a = this._items).push.apply(_a, this.mapper.Map(sources));
            return this;
        };
        // TODO: This must not fall over if trying to perform an action
        // on an inappropriate type. eg setting an attribute on window, or
        // trying to query a non-parent node..
        ChainedQuery.prototype.each = function (func) {
            this._items.forEach(function (item, i) { return func(item, i); });
            return this;
        };
        ChainedQuery.prototype.prop = function (name, value) {
            return this.each(function (item) {
                if (name in item) {
                    item[name] = value;
                }
            });
        };
        //#region Targets
        ChainedQuery.prototype.fire = function (eventName, detail) {
            var evt = new CustomEvent(eventName, { detail: detail });
            this.targets.forEach(function (t) { return t.dispatchEvent(evt); });
            return this;
        };
        ChainedQuery.prototype.on = function (eventNames, func) {
            var evts = eventNames.split(ChainedQuery.WHITESPACE_RGX);
            this.targets.forEach(function (t) {
                evts.forEach(function (name) { return t.addEventListener(name, func); });
            });
            return this;
        };
        //#endregion
        //#region Elements
        ChainedQuery.prototype.attr = function (name, value, ns) {
            this.elements.forEach(function (elem) {
                if (value != null)
                    elem.setAttributeNS(ns, name, value);
                else
                    elem.removeAttributeNS(ns, name);
            });
            return this;
        };
        ChainedQuery.prototype.toggle = function (className, doSet) {
            this.elements.forEach(function (elem) {
                var force = typeof doSet === 'function' ? doSet(elem) : !!doSet;
                elem.classList.toggle(className, force);
            });
            return this;
        };
        //#endregion
        //#region Nodes
        ChainedQuery.prototype.empty = function () {
            this.nodes.forEach(function (n) {
                while (n.firstChild) {
                    n.removeChild(n.firstChild);
                }
            });
            return this;
        };
        ChainedQuery.prototype.remove = function () {
            return new (ChainedQuery.bind.apply(ChainedQuery, __spreadArrays([void 0, this.mapper], this._items.filter(function (it) {
                var handle = it instanceof Node;
                if (handle)
                    it.parentNode.removeChild(it);
                return !handle;
            }))))();
        };
        //#endregion
        //#region Containers
        ChainedQuery.prototype.append = function () {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            this.appendIn.apply(this, sources);
            return this;
        };
        ChainedQuery.prototype.appendIn = function () {
            var _this = this;
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            return new (ChainedQuery.bind.apply(ChainedQuery, __spreadArrays([void 0, this.mapper], this.containers.reduce(function (acc, parent) {
                var nodes = new (ChainedQuery.bind.apply(ChainedQuery, __spreadArrays([void 0, _this.mapper], sources)))().nodes;
                parent.append.apply(parent, nodes);
                acc.push.apply(acc, nodes);
                return acc;
            }, []))))();
        };
        ChainedQuery.prototype.find = function (selector) {
            return new (ChainedQuery.bind.apply(ChainedQuery, __spreadArrays([void 0, this.mapper], this.containers.reduce(function (acc, parent) {
                acc.push.apply(acc, Array.from(parent.querySelectorAll(selector)));
                return acc;
            }, []))))();
        };
        ChainedQuery.prototype.first = function (selector) {
            return new (ChainedQuery.bind.apply(ChainedQuery, __spreadArrays([void 0, this.mapper], this.containers.map(function (parent) { return parent.querySelector(selector); }).filter(function (found) { return !!found; }))))();
        };
        ChainedQuery.WHITESPACE_RGX = /\s+/;
        return ChainedQuery;
    }());

    var SourceMapper = /** @class */ (function () {
        function SourceMapper() {
        }
        SourceMapper.prototype.Map = function (sources) {
            return sources.reduce(function (acc, item) {
                if (typeof item === 'string') {
                    acc.push.apply(acc, (SourceMapper.NAIVE_HTML_RGX.test(item)
                        ? SourceMapper.MapHTML(item)
                        : SourceMapper.MapSelector(item)));
                }
                else if (item.tag)
                    acc.push(SourceMapper.MapParam(item));
                else if (item instanceof Node)
                    acc.push(item);
                else if (item instanceof EventTarget)
                    acc.push(item);
                else if (item instanceof ChainedQuery)
                    item.each(function (i) { return acc.push(i); });
                else
                    console.warn('Unrecognised item:', item);
                return acc;
            }, []);
        };
        SourceMapper.MapHTML = function (html) {
            var template = document.createElement('template');
            template.innerHTML = html;
            return Array.from(template.content.childNodes);
        };
        SourceMapper.MapSelector = function (selector) {
            return Array.from(document.querySelectorAll(selector));
        };
        SourceMapper.MapParam = function (p) {
            var n = document.createElement(p.tag);
            if (p.text)
                n.textContent = p.text;
            for (var key in p.attr || {}) {
                if (p.attr[key] != null) {
                    n.setAttribute(key, p.attr[key]);
                }
            }
            for (var key in p.evts || {}) {
                if (typeof p.evts[key] === 'function') {
                    n.addEventListener(key, p.evts[key]);
                }
            }
            return n;
        };
        SourceMapper.NAIVE_HTML_RGX = /^\s*<.*>\s*$/m;
        return SourceMapper;
    }());
    var mapper = new SourceMapper();
    function q() {
        var input = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            input[_i] = arguments[_i];
        }
        return new (ChainedQuery.bind.apply(ChainedQuery, __spreadArrays([void 0, mapper], input)))();
    }

    var markupUrl = "data:text/html;base64,PHNsb3Q+PC9zbG90Pg0KPHVsIGNsYXNzPSJ0b3AiPjwvdWw+DQo=";

    var stylesUrl = "data:text/css;base64,dWwsDQpsaSB7DQogIHBhZGRpbmc6IDA7DQogIG1hcmdpbjogMDsNCiAgZm9udDogaW5oZXJpdDsNCn0NCnNsb3QsDQpsaS5zcGxpdCAuaWNvbiB7DQogIGRpc3BsYXk6IG5vbmU7DQp9DQoudG9wOm5vdCgub3BlbiksDQp1bDpub3QoLnRvcCkgew0KICB2aXNpYmlsaXR5OiBoaWRkZW47DQp9DQoNCnVsIHsNCiAgYm9yZGVyOiB2YXIoLS1ib3JkZXIsIDFweCBzb2xpZCAjYmJiKTsNCiAgYmFja2dyb3VuZDogdmFyKC0tYmcsICNmZmYpOw0KICBib3gtc2hhZG93OiB2YXIoLS1ib3gtc2hhZG93LCAycHggMnB4IDNweCAjODg4KTsNCiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjZzOw0KICB6LWluZGV4OiA5OTk5OTk5Ow0KfQ0KDQoudG9wIHsNCiAgcG9zaXRpb246IGZpeGVkOw0KICBmb250LXNpemU6IHZhcigtLWZvbnQtc2l6ZSwgMC42NXJlbSk7DQogIHVzZXItc2VsZWN0OiBub25lOw0KfQ0KDQouaWNvbi5sZWZ0IHsNCiAgbGVmdDogMWVtOw0KICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTsNCn0NCi5pY29uLnJpZ2h0IHsNCiAgcmlnaHQ6IDFlbTsNCiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoNTAlLCAtNTAlKTsNCn0NCi5pY29uIHsNCiAgbWF4LXdpZHRoOiAxZW07DQogIG1heC1oZWlnaHQ6IDFlbTsNCiAgcG9zaXRpb246IGFic29sdXRlOw0KICB0b3A6IDUwJTsNCiAgbGluZS1oZWlnaHQ6IDA7DQp9DQoNCmxpID4gcDpub3QoOmVtcHR5KSB7DQogIG1hcmdpbjogMCAxZW07DQogIHdoaXRlLXNwYWNlOiBub3dyYXA7DQp9DQpsaS5kaXNhYmxlZCB7DQogIGNvbG9yOiB2YXIoLS1kaXNhYmxlZC1mZywgI2JiYik7DQp9DQpsaS5zcGxpdCB7DQogIGJvcmRlci10b3A6IHZhcigtLXNwbGl0LWJvcmRlciwgdmFyKC0tYm9yZGVyLCAxcHggc29saWQgI2JiYikpOw0KICBwYWRkaW5nOiAwOw0KICBtYXJnaW46IDAuM2VtOw0KfQ0KbGkuc3BsaXQ6Zmlyc3QtY2hpbGQsDQpsaS5zcGxpdDpsYXN0LWNoaWxkLA0KbGkuc3BsaXQgKyBsaS5zcGxpdCB7DQogIGRpc3BsYXk6IG5vbmU7DQp9DQpsaS5ob3Zlcjpub3QoLmRpc2FiZWQpOm5vdCguc3BsaXQpIHsNCiAgYmFja2dyb3VuZDogdmFyKC0taG92ZXItaXRlbS1iZywgI2JiYik7DQp9DQoudG9wLm9wZW4gbGkuaG92ZXIgPiB1bCB7DQogIHZpc2liaWxpdHk6IHZpc2libGU7DQp9DQpsaSB7DQogIG1hcmdpbjogMC4yZW0gMDsNCiAgcGFkZGluZzogMC41ZW0gMWVtOw0KICBkaXNwbGF5OiBmbGV4Ow0KICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47DQogIHRleHQtYWxpZ246IGxlZnQ7DQogIHBvc2l0aW9uOiByZWxhdGl2ZTsNCiAgY3Vyc29yOiBkZWZhdWx0Ow0KICBjb2xvcjogdmFyKC0tZmcsICMwMDApOw0KfQ0KDQpsaS5ncm91cDo6YWZ0ZXIgew0KICBjb250ZW50OiAnXDI1YjYnOw0KICBwb3NpdGlvbjogYWJzb2x1dGU7DQogIGZvbnQtc2l6ZTogMC42NWVtOw0KICByaWdodDogMDsNCiAgdG9wOiA1MCU7DQogIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpOw0KfQ0KDQp1bDpub3QoLnRvcCkgew0KICBwb3NpdGlvbjogYWJzb2x1dGU7DQogIGxlZnQ6IDEwMCU7DQogIHRvcDogLTAuMjVlbTsNCn0NCg0KdWwubmVzdGxlIHsNCiAgbGVmdDogMC41ZW07DQogIHRvcDogMTAwJTsNCn0NCg==";

    class NeMenu extends CustomElementBase {
        constructor() {
            super(NeMenu.Css, NeMenu.Html);
            this.top = this.root.querySelector('ul');
        }
        connectedCallback() {
            if (!this._connected) {
                setTimeout(() => this.reload());
                q(this.parentNode).on('contextmenu', (e) => this.onParentContext(e));
                q(this, this.parentNode).on('contextmenu wheel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
                q(this).on('mousedown', (e) => e.stopPropagation());
                q(window).on('mousedown resize wheel', () => this.close());
                this._connected = true;
            }
        }
        /** Opens the menu.  */
        open() {
            // close all menus
            const doc = this.parentElement.getRootNode();
            doc.querySelectorAll('ne14-menu').forEach((m) => m.close());
            // style this one as open
            this.top.classList.add('open');
            q(this).fire('menuopen');
        }
        /** Closes the menu. */
        close() {
            if (this.top.classList.contains('open')) {
                this.top.classList.remove('open');
                q(this).fire('menuclose');
            }
        }
        /** Reloads active contents based on client dom. */
        reload() {
            q(this.top)
                .empty()
                .append(...this.walk(this, false));
        }
        onParentContext(event) {
            if (this.isConnected) {
                // update position (y)
                const y = event.clientY;
                const height = this.top.offsetHeight;
                const posY = y + height + 2 > window.innerHeight ? y - height : y;
                this.top.style.top = `${Math.max(0, posY)}px`;
                // update position (x)
                const x = event.clientX;
                const width = this.top.offsetWidth;
                const posX = x + width + 2 > window.innerWidth ? x - width : x;
                this.top.style.left = `${Math.max(0, posX)}px`;
                // open
                this.open();
            }
        }
        walk(ul, parentDisabled, ref = '') {
            let levelItemNo = 0;
            return Array.from(ul.children)
                .filter((c) => c instanceof HTMLLIElement &&
                !c.classList.contains('hidden') &&
                (c.textContent || c.classList.contains('split')))
                .reduce((acc, li) => {
                var _a, _b, _c;
                const children = Array.from(li.children).map((el) => el);
                const a = children.find((n) => n instanceof HTMLAnchorElement);
                const ul = children.find((n) => n instanceof HTMLUListElement);
                const isSplit = li.classList.contains('split');
                const isGrouper = !isSplit && ul && ul.querySelector('li');
                const isDisabled = !isSplit && (parentDisabled || li.classList.contains('disabled'));
                const aChildren = Array.from((a === null || a === void 0 ? void 0 : a.children) || []).map((el) => el);
                const imgs = children
                    .concat(aChildren)
                    .filter((n) => n instanceof HTMLImageElement)
                    .map((n) => n);
                if (!isSplit)
                    levelItemNo++;
                const classes = [];
                if (isSplit)
                    classes.push('split');
                else {
                    if (isDisabled)
                        classes.push('disabled');
                    if (isGrouper)
                        classes.push('group');
                    if ((a === null || a === void 0 ? void 0 : a.target) === '_blank')
                        classes.push('click-out');
                    else if (a)
                        classes.push('click-in');
                }
                const bestTextNode = [...children, li].find((c) => c.innerText);
                const bestText = isSplit ? null : (_a = bestTextNode === null || bestTextNode === void 0 ? void 0 : bestTextNode.innerText) !== null && _a !== void 0 ? _a : `Item ${levelItemNo}`;
                const shortcut = isSplit || isGrouper ? null : li.getAttribute('aria-keyshortcuts');
                const liRef = `${ref}${levelItemNo}`;
                const eventDetail = { ref: liRef, title: bestText, origin: a || li };
                const handleClick = () => {
                    if (!isDisabled && !isGrouper && !isSplit) {
                        eventDetail.origin.click();
                        q(this).fire('itemselect', eventDetail);
                        this.close();
                    }
                };
                const handleMouseEnter = (e) => {
                    if (!isDisabled && !isSplit) {
                        const domLi = e.target;
                        if (isGrouper) {
                            const domUl = Array.from(domLi.children).find((n) => n instanceof HTMLUListElement);
                            const liRect = domLi.getBoundingClientRect();
                            domUl.classList.toggle('nestle', liRect.right + domUl.clientWidth + 2 > window.innerWidth);
                        }
                        domLi.classList.add('hover');
                        q(this).fire('itemhover', eventDetail);
                    }
                };
                const handleMouseLeave = (e) => {
                    if (!isDisabled && !isSplit) {
                        e.target.classList.remove('hover');
                        q(this).fire('itemunhover', eventDetail);
                    }
                };
                const $domItem = q({ tag: 'li' })
                    .attr('class', classes.length ? classes.join(' ') : null)
                    .attr('aria-keyshortcuts', shortcut)
                    .on('click contextmenu', handleClick)
                    .on('mouseenter', handleMouseEnter)
                    .on('mouseleave', handleMouseLeave);
                const charLeft = li.dataset.charLeft;
                const charRight = li.dataset.charRight;
                const imgLeft = imgs.find((i) => !i.classList.contains('right'));
                const imgRight = imgs.find((i) => i.classList.contains('right'));
                if (!isSplit && !isGrouper && bestText) {
                    if (NeMenu.CHAR_REF_REGEX.test(charLeft))
                        $domItem.append(`<span class='icon left'>&#x${charLeft};</span>`);
                    else if (charLeft)
                        console.warn(`ne14-menu: Bad hex code '${charLeft}' to left of '${bestText}'.`);
                    else if (imgLeft)
                        $domItem.append(`<img class='icon left' src='${imgLeft.src}'/>`);
                    if (NeMenu.CHAR_REF_REGEX.test(charRight))
                        $domItem.append(`<span class='icon right'>&#x${charRight};</span>`);
                    else if (charRight)
                        console.warn(`ne14-menu: Bad hex code '${charRight}' to right of '${bestText}'.`);
                    else if (imgRight)
                        $domItem.append(`<img class='icon right' src='${imgRight.src}'/>`);
                }
                if (bestText)
                    $domItem.append({ tag: 'p', text: bestText });
                if (shortcut)
                    $domItem.append({ tag: 'p', text: shortcut });
                if (isGrouper)
                    $domItem.appendIn({ tag: 'ul' }).append(...this.walk(ul, isDisabled, `${liRef}-`));
                // Do not push two consecutive splits
                if (!isSplit || !((_c = (_b = acc[acc.length - 1]) === null || _b === void 0 ? void 0 : _b.classList) === null || _c === void 0 ? void 0 : _c.contains('split'))) {
                    acc.push($domItem.elements[0]);
                }
                return acc;
            }, []);
        }
    }
    NeMenu.Css = reduceCss(decode(stylesUrl));
    NeMenu.Html = reduceHtml(decode(markupUrl));
    NeMenu.CHAR_REF_REGEX = /^[0-9a-f]{4,5}$/i;

    if ('customElements' in window) {
        window.customElements.define('ne14-menu', NeMenu);
    }

    /** The state of a cell. Values are unicode representations of the state. */
    var CellState;
    (function (CellState) {
        CellState[CellState["Blank"] = 9723] = "Blank";
        CellState[CellState["Marked"] = 9635] = "Marked";
        CellState[CellState["Filled"] = 9724] = "Filled";
    })(CellState || (CellState = {}));
    /** The type of a set of cells. */
    var SetType;
    (function (SetType) {
        SetType[SetType["Column"] = 0] = "Column";
        SetType[SetType["Row"] = 1] = "Row";
    })(SetType || (SetType = {}));

    class Label {
        constructor(value, index) {
            this.value = value;
            this.index = index;
            this.indexRef = `L${this.index}`;
        }
        /** Gets the minimum total size for a set of separated values. */
        static minSize(values) {
            return values.reduce((tot, curr) => {
                return tot > 0 ? curr + tot + 1 : curr + tot;
            }, 0);
        }
    }
    class LabelSetLink {
        constructor(labelIndex, setIndex, known) {
            this.labelIndex = labelIndex;
            this.setIndex = setIndex;
            this.known = known;
        }
    }

    /** A contiguous set of cells. */
    class CellSetBase {
        constructor(start, type, index, size) {
            this.start = start;
            this.type = type;
            this.index = index;
            this.size = size;
            this.end = this.start + this.size - 1;
        }
    }
    /** A set of consecutive 'filled' cells. */
    class BlockSet extends CellSetBase {
        constructor(start, type, index, size, spaceIndex) {
            super(start, type, index, size);
            this.start = start;
            this.type = type;
            this.index = index;
            this.size = size;
            this.spaceIndex = spaceIndex;
        }
    }
    /** A set of unmarked cells. */
    class SpaceSet extends CellSetBase {
    }

    /** A complete set of cells - representing a column or row. */
    class FullSet extends CellSetBase {
        constructor(start, type, index, cells, labelValues) {
            super(start, type, index, cells.length);
            this.start = start;
            this.type = type;
            this.index = index;
            this.cells = cells;
            this.labelSpaceMap = [];
            this.labelBlockMap = [];
            this.spaces = [];
            this.blocks = [];
            this.altType = this.type === SetType.Row ? SetType.Column : SetType.Row;
            this.labels = labelValues.map((v, i) => new Label(v, i));
            this.indexRef = `${SetType[this.type].substr(0, 3)} ${this.index}`;
            this.performCellPass(true);
            this.performCellPass(false);
            this.setLabelSpaces();
            this.setLabelBlocks();
            let linksChanged;
            do {
                linksChanged = this.updateMaps();
                this.applyBlockValueRanges();
                linksChanged = linksChanged || this.applyBlockPositionRanges();
                linksChanged = linksChanged || this.applyDistinctBlockPairing();
            } while (linksChanged);
        }
        get stateRef() {
            return `${this.cells.map((state) => String.fromCharCode(state)).join('')}`;
        }
        get consoleRef() {
            return `${this.indexRef}: ${this.stateRef} ${this.labelRef}`;
        }
        get labelRef() {
            return this.labels.map((l) => l.value).join('.');
        }
        get labelsRef() {
            return this.labels.map((l, i) => this.getLabelRef(i)).join(' / ');
        }
        get solved() {
            return !this.cells.some((state) => state === CellState.Blank);
        }
        /** Marks and fills all appropriate blocks, returning indices of the mark and fill cells. */
        solve() {
            const blanx = this.cells
                .map((cell, idx) => ({ c: cell, i: idx }))
                .filter((ic) => ic.c === CellState.Blank);
            const mIdx = this.labels
                .reduce((ac, l) => ac.filter((ib) => ib.i < l.earliest || ib.i > l.latest), blanx)
                .map((mark) => mark.i);
            const fIdx = this.labels
                .reduce((ac, l) => ac.concat(blanx.filter((ib) => ib.i < l.earliest + l.value && ib.i > l.latest - l.value)), [])
                .map((fill) => fill.i);
            this.blocks // Add fills for edged-out blocks
                .filter((b) => b.rightEdge !== b.end || b.leftEdge !== b.start)
                .forEach((b) => blanx
                .filter((ic) => ic.i >= b.leftEdge && ic.i <= b.rightEdge)
                .forEach((ci) => fIdx.push(ci.i)));
            this.blocks // Add marks to blocks at their maximum
                .filter((b) => 1 + b.rightEdge - b.leftEdge === b.maxSize)
                .forEach((b) => {
                mIdx.push(b.leftEdge - 1);
                mIdx.push(b.rightEdge + 1);
            });
            const mIdxFilt = blanx // mIdx was originally a Set to prevent duplicates, but array means es5.
                .filter((ic) => mIdx.indexOf(ic.i) !== -1)
                .map((ic) => ic.i)
                .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
            const fIdxFilt = blanx // fIdx was originally a Set to prevent duplicates; but array means es5.
                .filter((ic) => fIdx.indexOf(ic.i) !== -1)
                .map((ic) => ic.i)
                .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
            mIdxFilt.forEach((mInd) => (this.cells[mInd] = CellState.Marked));
            fIdxFilt.forEach((fInd) => (this.cells[fInd] = CellState.Filled));
            return { marks: mIdxFilt, fills: fIdxFilt };
        }
        getLabelRef(index) {
            const label = this.labels[index];
            const sLinks = this.getLinksForLabel(index, true).map((sl) => sl.setIndex + (sl.known ? 'K' : 'M'));
            const bLinks = this.getLinksForLabel(index, false).map((bl) => bl.setIndex + (bl.known ? 'K' : 'M'));
            return `${label.indexRef}: R=${label.earliest}-${label.latest} S=${sLinks} B=${bLinks}`;
        }
        getLinksForLabel(lIndex, forSpace) {
            return (forSpace ? this.labelSpaceMap : this.labelBlockMap).filter((mi) => mi.labelIndex === lIndex);
        }
        getLinksForSet(setIndex, forSpace) {
            return (forSpace ? this.labelSpaceMap : this.labelBlockMap).filter((mi) => mi.setIndex === setIndex);
        }
        deleteLink(lIndex, setIndex, forSpace) {
            const mapName = forSpace ? 'labelSpaceMap' : 'labelBlockMap';
            this[mapName] = this[mapName].filter((mi) => mi.labelIndex !== lIndex || mi.setIndex !== setIndex);
        }
        upsertLink(lIndex, setIndex, forSpace, known) {
            const map = forSpace ? this.labelSpaceMap : this.labelBlockMap;
            const mapItems = map.filter((mi) => mi.labelIndex === lIndex && mi.setIndex === setIndex);
            if (mapItems.length === 1) {
                mapItems[0].known = known;
            }
            else {
                map.push(new LabelSetLink(lIndex, setIndex, known));
            }
        }
        upsertLinks(lIndex, forSpace, sets, known) {
            sets.forEach((set) => this.upsertLink(lIndex, set.index, forSpace, known));
        }
        /**
         * Iterates cells in a particular direction. The forward pass sets spaces and blocks for the
         * set as well as earliest label positions. The backward pass sets labels latest positions only.
         * NB: This method is not reasonably capable of managing block-block interactions.
         */
        performCellPass(forwards) {
            let spaceStart = -1;
            let blockStart = -1;
            let blockIndex = -1;
            let labelStart = -1;
            let blocks = [];
            let labelIndex = forwards ? 0 : this.labels.length - 1;
            const allCells = forwards ? this.cells.slice(0) : this.cells.slice(0).reverse();
            const labelIncrementor = forwards ? 1 : -1;
            // Clone the array and explicitly terminate it by a marked cell
            allCells.concat([CellState.Marked]).forEach((cell, i) => {
                // START SPACE AND LABEL
                if (spaceStart === -1 && cell !== CellState.Marked) {
                    spaceStart = i;
                    labelStart = i;
                }
                // START BLOCK
                if (blockStart === -1 && cell === CellState.Filled) {
                    blockStart = i;
                }
                // LABEL
                const label = this.labels[labelIndex];
                // If the label has reached its end
                if (label && labelStart !== -1 && i - labelStart >= label.value) {
                    // If the left-bunched label ends with a block...
                    if (blockStart !== -1) {
                        labelStart = i - label.value;
                    }
                    else {
                        if (forwards) {
                            label.earliest = labelStart;
                        }
                        else {
                            label.latest = this.cells.length - (labelStart + 1);
                        }
                        labelStart += 1 + label.value;
                        labelIndex += labelIncrementor;
                    }
                }
                // END BLOCK
                const spaceIndex = this.spaces.length;
                if (blockStart !== -1 && cell !== CellState.Filled) {
                    const blockLen = i - blockStart;
                    blocks.push(new BlockSet(blockStart, this.type, ++blockIndex, blockLen, spaceIndex));
                    // Closing a block whose length exceeds the label value must reset label start
                    if (label && blockLen > label.value) {
                        labelStart = i + 1;
                    }
                    // If at the end of block, and we are still on the same label and it fitted ok
                    if (label && i - labelStart === label.value) {
                        if (forwards) {
                            label.earliest = labelStart;
                        }
                        else {
                            label.latest = this.cells.length - (labelStart + 1);
                        }
                        labelIndex += labelIncrementor;
                        labelStart += 1 + label.value;
                    }
                    blockStart = -1;
                }
                // END SPACE
                if (spaceStart !== -1 && cell === CellState.Marked) {
                    if (forwards) {
                        const space = new SpaceSet(spaceStart, this.type, spaceIndex, i - spaceStart);
                        this.spaces.push(space);
                        this.blocks.push(...blocks);
                    }
                    // If at the end of space, and we are still on the same label and it fitted ok
                    if (label && label.index === labelIndex && i - labelStart >= label.value) {
                        if (forwards) {
                            label.earliest = labelStart;
                        }
                        else {
                            label.latest = this.cells.length - (labelStart + 1);
                        }
                        labelIndex += labelIncrementor;
                    }
                    blocks = [];
                    spaceStart = -1;
                    labelStart = this.cells.length;
                }
            });
        }
        setLabelSpaces() {
            this.labels.forEach((l) => {
                const spaces = this.spaces.filter((s) => l.earliest <= s.end && l.latest >= s.start);
                if (spaces.length === 0) {
                    const msg = `At least one label could not be assigned`;
                    throw new RangeError(`${msg} - ${this.consoleRef}`);
                }
                this.upsertLinks(l.index, true, spaces, spaces.length === 1);
            });
        }
        setLabelBlocks() {
            this.labels.forEach((l) => {
                const labelSpaces = this.getLinksForLabel(l.index, true);
                const labelBlocks = labelSpaces.reduce((acc, curr) => {
                    // Blocks not exceeding label value, within range
                    const ranged = this.blocks.filter((b) => b.start >= l.earliest && b.end <= l.latest && b.size <= l.value);
                    return acc.concat(ranged);
                }, []);
                this.upsertLinks(l.index, false, labelBlocks, false);
            });
        }
        /** For each block with only 1 linked label, make the linkage known */
        updateMaps() {
            let linksChanged = false;
            this.blocks.forEach((block) => {
                const links = this.labelBlockMap.filter((bl) => bl.setIndex === block.index);
                if (links.length === 1) {
                    const lIdx = links[0].labelIndex;
                    const label = this.labels[lIdx];
                    // Make a block-label link 'known'
                    this.upsertLink(lIdx, block.index, false, true);
                    // Which requires: Updating earliest and latest values
                    const space = this.spaces.filter((s) => s.index === block.spaceIndex)[0];
                    label.earliest = Math.max(label.earliest, space.start, 1 + block.end - label.value);
                    label.latest = Math.min(label.latest, space.end, block.start + label.value - 1);
                    // And: Removing space-links no longer in range
                    this.getLinksForLabel(lIdx, true)
                        .map((ls) => this.spaces[ls.setIndex])
                        .filter((s) => label.earliest > s.end || label.latest < s.start)
                        .forEach((deadLink) => this.deleteLink(lIdx, deadLink.index, true));
                    // Which itself requires: If one maybe space, making this known
                    this.getLinksForLabel(lIdx, true)
                        .filter((ls, i, arr) => arr.length === 1)
                        .forEach((knownLink) => this.upsertLink(lIdx, knownLink.setIndex, true, true));
                    // And finally: Removing block-links no longer in range
                    this.labelBlockMap
                        .filter((lb) => lb.setIndex !== block.index && lb.labelIndex === lIdx)
                        .map((lb) => this.blocks[lb.setIndex])
                        .filter((b) => b.start > label.latest || b.end < label.earliest)
                        .forEach((deadLink) => {
                        linksChanged = true;
                        this.deleteLink(lIdx, deadLink.index, false);
                    });
                }
            });
            return linksChanged;
        }
        /** Now the maps are good set min and max values based on labels. */
        applyBlockValueRanges() {
            this.blocks.forEach((block) => {
                block.minSize = this.cells.length;
                block.maxSize = 0;
                this.getLinksForSet(block.index, false)
                    .map((bl) => this.labels[bl.labelIndex])
                    .forEach((l) => {
                    block.minSize = Math.min(block.minSize, l.value);
                    block.maxSize = Math.max(block.maxSize, l.value);
                });
            });
        }
        /** Now min and max are good, inspect for unbridgable blocks and return whether links have changed as a result. */
        applyBlockPositionRanges() {
            let linksChanged = false;
            this.blocks.forEach((block, bIdx) => {
                const space = this.spaces.filter((s) => s.index === block.spaceIndex)[0];
                const sibBlocks = this.blocks.filter((b) => b.spaceIndex === block.spaceIndex);
                // Neighbouring unbridgable blocks
                const prevUnBlk = sibBlocks.filter((b) => b.index === bIdx - 1 && 1 + block.start - b.maxSize > b.end)[0];
                const nextUnBlk = sibBlocks.filter((b) => b.index === bIdx + 1 && block.end + b.maxSize - 1 < b.start)[0];
                const unlEdge = prevUnBlk == null ? space.start : prevUnBlk.end + 2;
                const unrEdge = nextUnBlk == null ? space.end : nextUnBlk.start - 2;
                if (prevUnBlk) {
                    linksChanged = linksChanged || this.tryRemoveLinks(bIdx, false);
                }
                if (nextUnBlk) {
                    linksChanged = linksChanged || this.tryRemoveLinks(bIdx, true);
                }
                // Edging away from calculated edges
                block.leftEdge = Math.min(block.start, 1 + unrEdge - block.minSize);
                block.rightEdge = Math.max(block.end, unlEdge + block.minSize - 1);
                // If edged out, update known labels of the block according to new limits
                if (block.leftEdge < block.start || block.rightEdge > block.end) {
                    this.labelBlockMap
                        .filter((bl) => bl.setIndex === block.index && bl.known)
                        .forEach((bl) => {
                        const label = this.labels[bl.labelIndex];
                        label.earliest = Math.max(label.earliest, space.start, 1 + block.rightEdge - label.value);
                        label.latest = Math.min(label.latest, space.end, block.leftEdge + label.value - 1);
                    });
                }
            });
            return linksChanged;
        }
        /** Checks whether block and neighbouring unbridgable block need labels removing. */
        tryRemoveLinks(blockIndex, forNext) {
            const neighbourIndex = forNext ? blockIndex + 1 : blockIndex - 1;
            const blockLabelLinks = this.getLinksForSet(blockIndex, false);
            const blockLabelIdx = this.getLinksForSet(blockIndex, false)
                .map((li) => li.labelIndex)
                .join(',');
            const unbrLabelIdx = this.getLinksForSet(neighbourIndex, false)
                .map((li) => li.labelIndex)
                .join(',');
            if (blockLabelLinks.length === 2 && unbrLabelIdx === blockLabelIdx) {
                this.deleteLink(blockLabelLinks[forNext ? 0 : 1].labelIndex, neighbourIndex, false);
                this.deleteLink(blockLabelLinks[forNext ? 1 : 0].labelIndex, blockIndex, false);
                return true;
            }
            return false;
        }
        /** Removes block/label links where label count matches distinct block count */
        applyDistinctBlockPairing() {
            let linksChanged;
            let prevBlock;
            let prevInReach;
            let labelIndex;
            const labelAssignment = [];
            // Assemble distinct block count by label index
            this.blocks.forEach((currBlock, blockIndex) => {
                prevBlock = this.blocks[blockIndex - 1];
                prevInReach =
                    prevBlock &&
                        prevBlock.spaceIndex === currBlock.spaceIndex &&
                        prevBlock.start + prevBlock.maxSize - 1 >= currBlock.rightEdge;
                labelIndex = prevInReach ? labelAssignment.length - 1 : labelAssignment.length;
                labelAssignment[labelIndex] = labelAssignment[labelIndex] || [];
                labelAssignment[labelIndex].push(blockIndex);
            });
            // If counts match, remove block links except for those assembled
            if (labelAssignment.length === this.labels.length) {
                this.labels.forEach((lbl) => {
                    this.getLinksForLabel(lbl.index, false)
                        .filter((ln) => labelAssignment[lbl.index].indexOf(ln.setIndex) === -1)
                        .forEach((dl) => {
                        linksChanged = true;
                        this.deleteLink(dl.labelIndex, dl.setIndex, false);
                    });
                });
                return linksChanged;
            }
            return false;
        }
    }

    /** The outcome of running a 'solve' grid method. */
    class SolveResult {
        constructor(gridObject, solved, solvedMs) {
            this.solved = solved;
            this.solvedMs = solvedMs;
            if (solved) {
                this.grid = gridObject;
            }
            else {
                this.brokenGrid = gridObject;
            }
        }
    }

    class Utils {
        /** Returns a new array of the specified size filled with the specified value. */
        static FillArray(size, valuer) {
            const retVal = new Array(size);
            for (let i = 0; i < size; i++) {
                retVal[i] = valuer();
            }
            return retVal;
        }
        /** Pools multiple events, firing once per delay cycle. */
        static Throttle(func, delay = 200) {
            let active;
            return function (args) {
                if (!active) {
                    if (active == null)
                        func.call(this, args);
                    active = true;
                    const that = this;
                    setTimeout(() => {
                        active = !!func.call(that, args);
                        setTimeout(() => (active = active || null), delay / 10);
                    }, delay);
                }
            };
        }
        /** Pools multiple events, firing once after the delay period. */
        static Debounce(func, delay = 200) {
            let timeout;
            return function (arg) {
                clearTimeout(timeout);
                const that = this;
                timeout = setTimeout(() => func.call(that, arg), delay);
            };
        }
    }

    /** A griddler grid. */
    class Grid {
        constructor(width, height) {
            this.width = width;
            this.height = height;
            this._rowLabelCache = Utils.FillArray(this.height, () => []);
            this._columnLabelCache = Utils.FillArray(this.width, () => []);
            this._cellCache = this._columnLabelCache.map(() => Utils.FillArray(this.height, () => CellState.Blank));
        }
        static load(gridObject) {
            const grid = new Grid(gridObject.columns.length, gridObject.rows.length);
            gridObject.columns.forEach((col, colIdx) => {
                grid.setLabels(SetType.Column, colIdx, col.labels);
            });
            gridObject.rows.forEach((row, rowIdx) => {
                grid.setLabels(SetType.Row, rowIdx, row.labels);
                (row.cells || [])
                    .map((cell, cellIdx) => ({ oState: cell, idx: cellIdx }))
                    .filter((obj) => obj.oState !== 0)
                    .forEach((obj) => {
                    const state = obj.oState === 1 ? CellState.Filled : CellState.Marked;
                    grid.setState(SetType.Row, rowIdx, obj.idx, state);
                });
            });
            return grid;
        }
        get consoleRef() {
            return this._rowLabelCache.map((n, r) => this.getFullSet(SetType.Row, r).stateRef).join('\r\n');
        }
        get unsolvedCellCount() {
            return this._cellCache
                .reduce((ac, cur) => ac.concat(cur), [])
                .filter((state) => state === CellState.Blank).length;
        }
        get solved() {
            return !this._cellCache
                .reduce((ac, cur) => ac.concat(cur), [])
                .some((state) => state === CellState.Blank);
        }
        get gridObject() {
            return {
                columns: this._columnLabelCache.map((n, c) => ({
                    labels: this.getLabels(SetType.Column, c),
                })),
                rows: this._rowLabelCache.map((n, r) => {
                    return {
                        labels: this.getLabels(SetType.Row, r),
                        cells: this.getFullSet(SetType.Row, r).cells.map((c) => c === CellState.Marked ? 2 : CellState.Filled ? 1 : 0),
                    };
                }),
            };
        }
        nextHint() {
            const allCols = Utils.FillArray(this.width, () => 0).map((x, i) => i);
            const allRows = Utils.FillArray(this.height, () => 0).map((x, i) => i);
            const colsrows = this.solveSetsRecursively([allCols, allRows], true);
            let result = null;
            if (colsrows) {
                const pass = colsrows[263 % colsrows.length];
                result = { type: SetType[pass.type], idx: pass.idx };
            }
            return result;
        }
        solve() {
            const t0 = new Date().getTime();
            const allCols = Utils.FillArray(this.width, () => 0).map((x, i) => i);
            const allRows = Utils.FillArray(this.height, () => 0).map((x, i) => i);
            this.solveSetsRecursively([allCols, allRows]);
            const t1 = new Date().getTime();
            return new SolveResult(this.gridObject, this.solved, t1 - t0);
        }
        setState(setType, setIndex, cellIndex, state) {
            if (setType === SetType.Row) {
                this._cellCache[cellIndex][setIndex] = state;
            }
            else {
                this._cellCache[setIndex][cellIndex] = state;
            }
        }
        setLabels(type, index, values) {
            const setRef = `${SetType[type].substr(0, 3)} ${index}`;
            const target = type === SetType.Row ? this._rowLabelCache : this._columnLabelCache;
            if (target[index] == null) {
                const msg = 'Not found';
                throw new RangeError(`${setRef}: ${msg}`);
            }
            const setSize = type === SetType.Row ? this.width : this.height;
            const minSize = Label.minSize(values);
            if (minSize > setSize) {
                const msg = `The minimum total label size (${minSize}) exceeds the set length (${setSize})`;
                throw new RangeError(`${setRef}: ${msg}`);
            }
            target[index] = values;
        }
        getFullSet(type, index) {
            const cells = type === SetType.Row ? this._cellCache.map((val) => val[index]) : this._cellCache[index];
            return new FullSet(0, type, index, cells, this.getLabels(type, index));
        }
        getLabels(type, index) {
            return type === SetType.Row ? this._rowLabelCache[index] : this._columnLabelCache[index];
        }
        solveSetsRecursively(colsrows, shallow = false) {
            const allUnsolvedHintworthy = colsrows[0]
                .map((c) => this.getFullSet(SetType.Column, c))
                .concat(colsrows[1].map((r) => this.getFullSet(SetType.Row, r)))
                .filter((set) => !set.solved)
                .map((us) => {
                const cr = us.solve();
                cr.marks.forEach((m) => this.setState(us.type, us.index, m, CellState.Marked));
                cr.fills.forEach((f) => this.setState(us.type, us.index, f, CellState.Filled));
                return {
                    type: us.type,
                    idx: us.index,
                    crType: us.altType,
                    crIdx: cr.marks.concat(cr.fills),
                };
            })
                .filter((obj) => obj.crIdx.length !== 0);
            if (shallow) {
                return allUnsolvedHintworthy;
            }
            const allUnsolved = allUnsolvedHintworthy
                .reduce((ac, obj) => {
                ac[obj.crType].push(...obj.crIdx);
                return ac;
            }, [[], []])
                .map((arr) => arr.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0)).filter((n, i, x) => !i || n !== x[i - 1]));
            if (allUnsolved[0].length + allUnsolved[1].length !== 0) {
                this.solveSetsRecursively([allUnsolved[0], allUnsolved[1]]);
            }
            return null;
        }
    }

    class XGrid {
        static AsPlain(grid) {
            const g = grid;
            const retVal = grid instanceof ImageData
                ? XGrid.FromImage(grid)
                : g.x && g.y
                    ? XGrid.CreatePlain(g.x, g.y)
                    : g.c && g.r
                        ? XGrid.ToPlain(grid)
                        : g.rows && g.columns
                            ? grid
                            : null;
            if (retVal == null) {
                throw new RangeError('Unable to interpret as a plain grid.');
            }
            return retVal;
        }
        static ToDense(plain) {
            const derive = (ds) => {
                if (!ds.cells || (ds.cells.indexOf(1) === -1 && ds.cells.indexOf(2) === -1)) {
                    return '';
                }
                const data = ds.cells
                    .reduce((acc, cur, i) => {
                    const symbol = cur === 2 ? 'm' : cur === 1 ? 'f' : 'e';
                    const isLast = i === ds.cells.length - 1;
                    if (!acc.symbol) {
                        acc.symbol = symbol;
                        acc.count = 0;
                    }
                    if (acc.symbol === symbol) {
                        acc.count++;
                    }
                    if (acc.count !== 0 && (acc.symbol !== symbol || isLast)) {
                        if (acc.symbol !== symbol) {
                            acc.items.push(`${acc.symbol}${acc.count === 1 ? '' : acc.count}`);
                            acc.count = 1;
                            acc.symbol = symbol;
                        }
                        if (isLast) {
                            acc.items.push(`${acc.symbol}${acc.count === 1 ? '' : acc.count}`);
                        }
                    }
                    return acc;
                }, { symbol: '', count: 0, items: [] })
                    .items.join('');
                return data ? `.${data}` : '';
            };
            return {
                c: plain.columns.map((c) => (c.labels || []).join('.')).join('|'),
                r: plain.rows.map((r) => `${(r.labels || []).join('.')}${derive(r)}`).join('|'),
            };
        }
        static OverlayResult(ref, result) {
            const palette = {
                fill: {
                    good: { r: 0, g: 0, b: 0, a: 255 },
                    bad: { r: 255, g: 0, b: 0, a: 255 },
                },
                mark: {
                    good: { r: 0, g: 0, b: 255, a: 32 },
                    bad: { r: 127, g: 0, b: 0, a: 255 },
                },
            };
            const plain = result.solved ? result.grid : result.brokenGrid;
            for (let x = 3; x < ref.data.length; x += 4) {
                const rowNum = Math.floor((x - 3) / 4 / ref.width);
                const colNum = ((x - 3) / 4) % ref.width;
                const state = plain.rows[rowNum].cells[colNum];
                const paletteState = state === 1 ? palette.fill : state === 2 && !result.solved ? palette.mark : null;
                if (paletteState) {
                    // blocks and (unsolved) marks
                    const wasBlock = ref.data[x - 3] === 0 && ref.data[x - 2] === 0 && ref.data[x - 1] === 0;
                    const stateRef = (state === 1 && wasBlock) || (state === 2 && !wasBlock) ? 'good' : 'bad';
                    const rgba = paletteState[stateRef];
                    ref.data[x - 3] = rgba.r;
                    ref.data[x - 2] = rgba.g;
                    ref.data[x - 1] = rgba.b;
                    ref.data[x] = rgba.a;
                }
            }
        }
        static WipeCells(plain) {
            const emptyRow = Utils.FillArray(plain.columns.length, () => 0);
            plain.rows.forEach((r) => (r.cells = emptyRow.slice()));
        }
        static WipeLabels(plain) {
            plain.rows.forEach((r) => (r.labels = []));
            plain.columns.forEach((c) => (c.labels = []));
        }
        static ScrapeLabels(plain) {
            XGrid.ScrapeColumnLabels(plain);
            const denseRows = XGrid.ToDense(plain).r.split('|');
            denseRows.forEach((row, i) => {
                plain.rows[i].labels = (row.match(/f\d*/g) || []).map((fd) => parseInt(fd.substring(1) || '1'));
            });
        }
        static CreatePlain(columns, rows) {
            const emptyRow = Utils.FillArray(columns, () => 0);
            return {
                columns: Utils.FillArray(columns, () => ({ labels: [] })),
                rows: Utils.FillArray(rows, () => ({ labels: [], cells: emptyRow.slice() })),
            };
        }
        static ToPlain(dense) {
            const cols = dense.c.split('|');
            const rows = dense.r.split('|');
            const retVal = XGrid.CreatePlain(cols.length, rows.length);
            retVal.columns.forEach((c, i) => {
                const labels = cols[i]
                    .split('.')
                    .map((l) => parseInt(l))
                    .filter((n) => !isNaN(n));
                c.labels = labels.length > 0 ? labels : [];
            });
            retVal.rows.forEach((r, i) => {
                const dataArray = rows[i].split('.');
                const labels = dataArray.map((l) => parseInt(l)).filter((n) => !isNaN(n));
                r.labels = labels.length > 0 ? labels : [];
                if (labels.length === 0 || dataArray.length === labels.length + 1) {
                    r.cells = dataArray
                        .pop()
                        .split(/(?=[mfe]\d*)/)
                        .reduce((acc, cur) => {
                        const numero = cur[0] === 'm' ? 2 : cur[0] === 'f' ? 1 : 0;
                        const freq = cur ? parseInt(cur.substring(1)) || 1 : cols.length;
                        acc = acc.concat(Utils.FillArray(freq, () => numero));
                        return acc;
                    }, []);
                }
            });
            return retVal;
        }
        static FromImage(img) {
            const retVal = XGrid.CreatePlain(img.width, img.height);
            for (let x = 3; x < img.data.length; x += 4) {
                const rowNum = Math.floor((x - 3) / 4 / img.width);
                const colNum = ((x - 3) / 4) % img.width;
                const isBlock = img.data[x - 3] === 0 && img.data[x - 2] === 0 && img.data[x - 1] === 0;
                if (isBlock)
                    retVal.rows[rowNum].cells[colNum] = 1;
            }
            return retVal;
        }
        /** Scrapes column labels from cell state */
        static ScrapeColumnLabels(plain) {
            plain.columns.forEach((col, c) => {
                col.labels = [];
                let run = 0;
                for (let r = 0; r < plain.rows.length; r++) {
                    const isBlock = plain.rows[r].cells[c] === 1;
                    if (isBlock)
                        run++;
                    if (run > 0 && (!isBlock || r === plain.rows.length - 1)) {
                        col.labels.push(run);
                        run = 0;
                    }
                }
            });
        }
    }

    var markupUrl$1 = "data:text/html;base64,PGRpdiBjbGFzcz0iYmFjayI+DQogIDxkaXYgY2xhc3M9ImZvcmUiPg0KICAgIDxzbG90Pjwvc2xvdD4NCiAgICA8c3BhbiBjbGFzcz0iY2xvc2UiPiZ0aW1lczs8L3NwYW4+DQogICAgPHNwYW4gY2xhc3M9InNlLXJlc2l6ZSI+JiN4MjVlMjs8L3NwYW4+DQogIDwvZGl2Pg0KPC9kaXY+DQo=";

    var stylesUrl$1 = "data:text/css;base64,LmJhY2sgew0KICBwb3NpdGlvbjogZml4ZWQ7DQogIHRvcDogMDsNCiAgcmlnaHQ6IDA7DQogIGJvdHRvbTogMDsNCiAgbGVmdDogMDsNCiAgYmFja2dyb3VuZDogdmFyKC0tYmFja2dyb3VuZCwgcmdiYSgwLCAwLCAwLCAwLjg1KSk7DQogIG9wYWNpdHk6IDA7DQogIG92ZXJmbG93OiBoaWRkZW47DQogIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zczsNCiAgei1pbmRleDogOTk5OTk7DQp9DQouYmFjazpub3QoLm9wZW4pIHsNCiAgcG9pbnRlci1ldmVudHM6IG5vbmU7DQp9DQouYmFjay5vcGVuIHsNCiAgb3BhY2l0eTogMTsNCn0NCi5iYWNrLm9wZW4gLmZvcmUucmVhZHkgew0KICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuM3MsIGJhY2tncm91bmQtY29sb3IgMC4zczsNCn0NCi5mb3JlLm92ZXIgew0KICBjdXJzb3I6IG1vdmU7DQogIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjUwLCAyNTAsIDI1MCwgMSk7DQp9DQouZm9yZS5tb3Zpbmcgew0KICBjdXJzb3I6IGNyb3NzaGFpcjsNCiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzAsIDIzMCwgMjMwLCAxKTsNCiAgdXNlci1zZWxlY3Q6IG5vbmU7DQp9DQouZm9yZS5vdmVyLA0KLmZvcmUubW92aW5nIHsNCiAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAuNWVtIGJsYWNrICFpbXBvcnRhbnQ7DQp9DQouZm9yZSB7DQogIGJhY2tncm91bmQtY29sb3I6ICNmZmY7DQogIG1pbi13aWR0aDogMXJlbTsNCiAgbWF4LXdpZHRoOiAxMDB2dzsNCiAgbWluLWhlaWdodDogMXJlbTsNCiAgbWF4LWhlaWdodDogMTAwdmg7DQogIHBvc2l0aW9uOiBhYnNvbHV0ZTsNCiAgb3ZlcmZsb3c6IGhpZGRlbjsNCiAgdG9wOiA1MCU7DQogIGxlZnQ6IDUwJTsNCiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3M7DQogIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMpOw0KICBib3gtc2hhZG93OiB2YXIoLS1ib3gtc2hhZG93KTsNCn0NCi5mb3JlID4gc3BhbiB7DQogIHBvc2l0aW9uOiBhYnNvbHV0ZTsNCiAgZm9udC1zaXplOiAxLjVlbTsNCiAgdXNlci1zZWxlY3Q6IG5vbmU7DQogIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMyk7DQp9DQouZm9yZS5uby1jbG9zZSB7DQogIG1heC13aWR0aDogY2FsYygxMDB2dyAtIDFlbSk7DQogIG1heC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAxZW0pOw0KfQ0KLmZvcmUubm8tY2xvc2UgLmNsb3NlIHsNCiAgZGlzcGxheTogbm9uZTsNCn0NCi5mb3JlIC5jbG9zZSB7DQogIGN1cnNvcjogcG9pbnRlcjsNCiAgdG9wOiAtNnB4Ow0KICByaWdodDogMDsNCiAgcGFkZGluZzogMC4yZW07DQp9DQouZm9yZTpub3QoLnJlc2l6ZSkgLnNlLXJlc2l6ZSB7DQogIGRpc3BsYXk6IG5vbmU7DQp9DQouZm9yZSAuc2UtcmVzaXplIHsNCiAgY3Vyc29yOiBzZS1yZXNpemU7DQogIGJvdHRvbTogLTlweDsNCiAgcmlnaHQ6IC00cHg7DQp9DQo=";

    class Popup extends CustomElementBase {
        constructor() {
            super(Popup.Css, Popup.Html);
            const back = this.root.querySelector('.back');
            const fore = back.querySelector('.fore');
            const resizer = fore.querySelector('.se-resize');
            const closer = fore.querySelector('.close');
            this.resetOffscreenPosition(fore);
            closer.addEventListener('click', () => this.close());
            resizer.addEventListener('mousedown', () => {
                fore.classList.toggle('over', this.canResize);
                fore.classList.toggle('resizing', this.canResize);
                if (!this.canShrink && !fore.style.minWidth) {
                    const rect = fore.getBoundingClientRect();
                    fore.style.minWidth = rect.width + 'px';
                    fore.style.minHeight = rect.height + 'px';
                }
            });
            back.addEventListener('mousedown', (event) => {
                this._drag = event.target === back ? 'back' : event.target === fore ? 'fore' : 'fore*';
                this._coords = this._drag !== 'fore' ? null : { x: event.offsetX, y: event.offsetY };
                fore.classList.toggle('moving', this.canMove && this._drag === 'fore');
            });
            fore.addEventListener('mouseover', (event) => fore.classList.toggle('over', this.canMove && event.target === fore));
            fore.addEventListener('mouseout', () => fore.classList.remove('over'));
            window.addEventListener('mousemove', (event) => {
                const rect = fore.getBoundingClientRect();
                if (fore.classList.contains('resizing')) {
                    const adjust = 5;
                    fore.style.width = adjust + event.pageX - rect.x + 'px';
                    fore.style.height = adjust + event.pageY - rect.y + 'px';
                }
                else if (this.canMove && this._drag === 'fore' && this._coords) {
                    const backRect = back.getBoundingClientRect();
                    const deltaW = backRect.width - window.innerWidth;
                    const deltaH = backRect.height - window.innerHeight;
                    const x_min_pc = (100 * Math.max(0, event.pageX - this._coords.x)) / window.innerWidth;
                    const y_min_pc = (100 * Math.max(0, event.pageY - this._coords.y)) / window.innerHeight;
                    const x_css = `min(${x_min_pc.toFixed(2)}vw, ${deltaW}px + 100vw - 100%)`;
                    const y_css = `min(${y_min_pc.toFixed(2)}vh, ${deltaH}px + 100vh - 100%)`;
                    fore.style.top = fore.style.left = '0';
                    fore.style.transform = `translate(${x_css}, ${y_css})`;
                }
            });
            window.addEventListener('mouseup', () => {
                this._drag = null;
                fore.classList.remove('moving', 'resizing');
            });
            back.addEventListener('mouseup', (event) => {
                if (this._drag === 'back' && event.target === back)
                    this.dismiss();
                this._drag = null;
                fore.classList.remove('moving', 'resizing');
            });
            fore.addEventListener('transitionend', (event) => {
                if (event.propertyName === 'transform') {
                    if (back.classList.contains('open')) {
                        fore.classList.add('ready');
                    }
                    else
                        this.resetOffscreenPosition(fore);
                }
            });
        }
        get canMove() {
            return this.hasAttribute('move');
        }
        get canResize() {
            return this.hasAttribute('resize');
        }
        get canShrink() {
            return this.canResize && this.hasAttribute('shrink');
        }
        get canClose() {
            return !this.hasAttribute('no-close');
        }
        close() {
            this.removeAttribute('open');
        }
        open() {
            this.setAttribute('open', '');
        }
        wrap(selectorOrElem) {
            const target = typeof selectorOrElem.append === 'function'
                ? selectorOrElem
                : document.querySelector(selectorOrElem + '');
            this.appendChild(target);
        }
        confirm() {
            const doCheck = !!this.confirmCallback;
            const proceed = !doCheck || this.confirmCallback();
            if (doCheck)
                this.fire(proceed ? 'confirmaccept' : 'confirmreject');
            if (proceed)
                this.close();
        }
        dismiss() {
            const doCheck = !!this.dismissCallback;
            const proceed = !doCheck || this.dismissCallback();
            if (doCheck)
                this.fire(proceed ? 'dismissaccept' : 'dismissreject');
            if (proceed)
                this.close();
        }
        attributeChangedCallback(name, oldValue, newValue) {
            switch (name) {
                case 'open':
                    const back = this.root.querySelector('.back');
                    const fore = back.querySelector('.fore');
                    const doOpen = !!newValue || typeof newValue === 'string';
                    fore.classList.remove('ready', 'moving');
                    fore.style.transform = doOpen
                        ? 'translate(-50%, -50%)'
                        : fore.style.transform + ' translateY(-100vh)';
                    fore.classList.toggle('resize', this.canResize);
                    fore.classList.toggle('no-close', !this.canClose);
                    back.classList.toggle('open', doOpen);
                    if (doOpen) {
                        fore.style.minWidth = fore.style.width = '';
                        fore.style.minHeight = fore.style.height = '';
                    }
                    this.fire(doOpen ? 'open' : 'close');
                    break;
            }
        }
        connectedCallback() {
            const back = this.root.querySelector('.back');
            const fore = back.querySelector('.fore');
            if (back.classList.contains('open')) {
                fore.classList.add('ready');
            }
        }
        resetOffscreenPosition(fore) {
            fore.style.left = '50%';
            fore.style.top = '50%';
            fore.style.transform = 'translate(-50%, -100vh)';
        }
        /** Emits a new event. */
        fire(event, detail) {
            this.dispatchEvent(new CustomEvent(event, { detail }));
        }
    }
    Popup.observedAttributes = ['open'];
    Popup.Css = reduceCss(decode(stylesUrl$1));
    Popup.Html = reduceHtml(decode(markupUrl$1));

    if ('customElements' in window) {
        window.customElements.define('ne14-pop', Popup);
    }

    var markupUrl$2 = "data:text/html;base64,PGRpdiBjbGFzcz0iYm9keSI+DQogIDxoMSBpZD0idGl0bGUiPjwvaDE+DQogIDxkaXYgaWQ9InpvbmUiPjwvZGl2Pg0KICA8ZGl2IGlkPSJlcnJvcnMiPjwvZGl2Pg0KICA8ZGl2IGlkPSJidXR0b25zIj4NCiAgICA8aW5wdXQgdHlwZT0iYnV0dG9uIiBpZD0iYnRuQ2FuY2VsIiB2YWx1ZT0iQ2FuY2VsIiAvPg0KICAgIDxpbnB1dCB0eXBlPSJidXR0b24iIGlkPSJidG5TYXZlIiB2YWx1ZT0iU2F2ZSIgLz4NCiAgPC9kaXY+DQo8L2Rpdj4NCg==";

    var stylesUrl$2 = "data:text/css;base64,LmJvZHkgew0KICBwYWRkaW5nOiAwLjVlbTsNCiAgYm94LXNpemluZzogYm9yZGVyLWJveDsNCiAgY29sb3I6ICM1NTU7DQogIGZvbnQtZmFtaWx5OiAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7DQogIHBvaW50ZXItZXZlbnRzOiBub25lOw0KICBoZWlnaHQ6IDEwMCU7DQogIGRpc3BsYXk6IGZsZXg7DQogIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47DQp9DQoNCmlucHV0IHsNCiAgZm9udDogaW5oZXJpdDsNCiAgcG9pbnRlci1ldmVudHM6IGFsbDsNCn0NCg0KI3RpdGxlIHsNCiAgZm9udC1zaXplOiAxLjNlbTsNCiAgbWFyZ2luOiAwLjI1ZW0gMDsNCn0NCiNlcnJvcnMgew0KICBjb2xvcjogI2YwMDsNCiAgZm9udC1zaXplOiAwLjhlbTsNCiAgZmxleC1ncm93OiAxOw0KfQ0KI2Vycm9ycyB1bCB7DQogIHBhZGRpbmctbGVmdDogMmVtOw0KfQ0KI2J1dHRvbnMgew0KICB0ZXh0LWFsaWduOiByaWdodDsNCiAgbWFyZ2luOiAwLjVlbTsNCn0NCg0KI3pvbmUgew0KICBwb2ludGVyLWV2ZW50czogYWxsOw0KICBvdmVyZmxvdy15OiBhdXRvOw0KfQ0KI3pvbmUgaW5wdXQuZXJyIHsNCiAgYm9yZGVyLWNvbG9yOiAjZjAwOw0KfQ0KI3pvbmUgaW5wdXQgew0KICBib3JkZXI6IDJweCBzb2xpZCAjZWVlOw0KICBib3JkZXItcmFkaXVzOiAycHg7DQogIHdpZHRoOiAyLjVlbTsNCiAgcGFkZGluZzogMC4yZW07DQogIHRleHQtYWxpZ246IHJpZ2h0Ow0KICBtYXJnaW46IDAuMmVtOw0KfQ0KDQojYnRuU2F2ZSB7DQogIGNvbG9yOiAjZmZmOw0KICBiYWNrZ3JvdW5kOiAjMGQwOw0KfQ0KI2J0blNhdmU6ZGlzYWJsZWQgew0KICBvcGFjaXR5OiAwLjM7DQp9DQoNCmlucHV0W3R5cGU9J2J1dHRvbiddOm5vdCg6ZGlzYWJsZWQpIHsNCiAgY3Vyc29yOiBwb2ludGVyOw0KfQ0KaW5wdXRbdHlwZT0nYnV0dG9uJ10gew0KICBib3JkZXI6IDFweCBzb2xpZCAjYWFhOw0KfQ0K";

    class GriddlerPopupBase extends Popup {
        constructor(zoneMarkupUrl, moreStylesUrl, move = true, resize = true) {
            super();
            if (move)
                q(this).attr('move', '');
            if (resize)
                q(this).attr('resize', '');
            q(this).on('open', () => this.onOpen());
            const styleTagParams = [{ tag: 'style', text: reduceCss(decode(stylesUrl$2)) }];
            if (moreStylesUrl)
                styleTagParams.push({ tag: 'style', text: reduceCss(decode(moreStylesUrl)) });
            this.$body = q(this.root)
                .find('.fore')
                .append(reduceHtml(decode(markupUrl$2)))
                .append(...styleTagParams)
                .find('.body');
            // Clicking cancel bypasses dismiss() handling by closing regardless
            this.$body.first('#btnCancel').on('click', () => this.close());
            this.$body.first('#btnSave').on('click', () => this.confirm());
            this.$zone = this.$body.first('#zone');
            if (zoneMarkupUrl) {
                this.$zone.append(reduceHtml(decode(zoneMarkupUrl)));
            }
            this.confirmCallback = () => this.validate();
            this.dismissCallback = () => !this.dirty || window.confirm('Abandon changes?');
        }
        set titleText(value) {
            this.$body.first('#title').elements[0].textContent = value;
        }
        set errors(value) {
            const $err = this.$body.first('#errors').empty();
            if (value.length > 0) {
                const $list = $err.appendIn({ tag: 'ul' });
                value.forEach((it) => $list.append({ tag: 'li', text: it }));
            }
        }
        onOpen() {
            this.dirty = false;
            this.renderZone();
            this.validate();
        }
    }

    class SettingsPopup extends GriddlerPopupBase {
        constructor() {
            super();
            this.titleText = 'Settings';
            // ...
        }
        renderZone() {
            // ...
        }
        validate() {
            // ...
            return true;
        }
    }

    var markupUrl$3 = "data:text/html;base64,PGRpdiBjbGFzcz0idGFibGUiPjwvZGl2Pg0K";

    var stylesUrl$3 = "data:text/css;base64,LnRhYmxlIC5yb3cgew0KICBkaXNwbGF5OiBmbGV4Ow0KfQ0KLnRhYmxlIC5yb3cuc2VsZWN0ZWQgew0KICBiYWNrZ3JvdW5kLWNvbG9yOiAjODhlZWNjOw0KfQ0K";

    class HistoryPopup extends GriddlerPopupBase {
        constructor() {
            super(markupUrl$3, stylesUrl$3);
            this.titleText = 'Change History';
        }
        renderZone() {
            const $table = this.$zone
                .first('.table')
                .empty()
                .append('<div class="header row"><p>Type</p><p>Date</p></div>');
            this.historyItems.forEach((item, i) => {
                $table
                    .appendIn(`<div><p>${item.type}</p><p>${item.date}</p></div>`)
                    .attr('class', i === this.historyIndex ? 'selected row' : 'row');
            });
        }
        validate() {
            // ...
            return true;
        }
    }

    class EditLabelPopup extends GriddlerPopupBase {
        constructor() {
            super();
        }
        get grace() {
            return this.capacity / 5;
        }
        renderZone() {
            const typeName = this.setType === 'columns' ? 'Column' : 'Row';
            this.titleText = `${typeName} ${this.setIndex + 1}`;
            this.$zone.empty();
            const minBoxes = Math.max(this.labels.length + 1, this.grace);
            for (let i = 0; i < minBoxes; i++) {
                this.addLabel(this.labels[i]);
            }
        }
        validate() {
            const ranged = this.$zone.find('input').elements.reduce((acc, cur) => {
                const val = parseInt(cur.value);
                cur.className = '';
                if (val) {
                    if (acc.tot)
                        acc.tot++;
                    acc.tot += val;
                    acc.res.push(val);
                    cur.className = acc.tot > this.capacity ? 'err' : '';
                }
                return acc;
            }, { tot: 0, res: [], err: [] });
            const diff = ranged.tot - this.capacity;
            if (diff > 0) {
                ranged.err.unshift(`${ranged.tot} is ${diff} too many! (max: ${this.capacity})`);
            }
            this.labels = ranged.res;
            this.errors = ranged.err;
            const valid = ranged.err.length === 0;
            const btnSave = this.$body.first('#btnSave').elements[0];
            btnSave.disabled = !valid;
            return valid;
        }
        addLabel(value) {
            this.$zone.append({
                tag: 'input',
                evts: { input: () => this.onLabelInput() },
                attr: {
                    type: 'number',
                    value: value ? `${value}` : '',
                    min: '0',
                    max: `${this.capacity}`,
                },
            });
        }
        onLabelInput() {
            this.dirty = true;
            this.validate();
        }
    }

    var markupUrl$4 = "data:text/html;base64,PGRpdiBjbGFzcz0icm9vdCI+DQogIDxjYW52YXMgaWQ9ImNhbnZhcyI+PC9jYW52YXM+DQoNCiAgPGZvcm0gaWQ9ImNvbnRyb2wtcGFuZWwiPg0KICAgIDxsYWJlbCBjbGFzcz0iZmlsdGVyIHBhcmFtIGJ3IHRoaW4iPg0KICAgICAgPHNwYW4+U2hhZGU8L3NwYW4+DQogICAgICA8aW5wdXQgaWQ9InNoYWRlIiBuYW1lPSJzaGFkZSIgdHlwZT0iY29sb3IiIC8+DQogICAgPC9sYWJlbD4NCg0KICAgIDxsYWJlbCBjbGFzcz0iZmlsdGVyIHBhcmFtIGJ3IHRoaW4iPg0KICAgICAgPHNwYW4+SW52ZXJ0PC9zcGFuPg0KICAgICAgPGlucHV0IGlkPSJpbnZlcnQiIG5hbWU9ImludmVydCIgdHlwZT0iY2hlY2tib3giIC8+DQogICAgPC9sYWJlbD4NCg0KICAgIDxsYWJlbCBjbGFzcz0iZmlsdGVyIHBhcmFtIGJ3Ij4NCiAgICAgIDxzcGFuPlRocmVzaG9sZDwvc3Bhbj4NCiAgICAgIDxpbnB1dCBpZD0idGhyZXNob2xkIiBuYW1lPSJ0aHJlc2hvbGQiIHR5cGU9InJhbmdlIiBtaW49IjAiIG1heD0iMjU1IiBzdGVwPSIxIiAvPg0KICAgIDwvbGFiZWw+DQoNCiAgICA8bGFiZWwgY2xhc3M9ImZpbHRlciBwYXJhbSBncyI+DQogICAgICA8c3Bhbj5TaGFkZXM8L3NwYW4+DQogICAgICA8aW5wdXQgaWQ9InNoYWRlcyIgbmFtZT0ic2hhZGVzIiB0eXBlPSJyYW5nZSIgbWluPSIyIiB2YWx1ZT0iNCIgbWF4PSIxNiIgc3RlcD0iMSIgLz4NCiAgICA8L2xhYmVsPg0KDQogICAgPGxhYmVsIGNsYXNzPSJwYXJhbSI+DQogICAgICA8c3Bhbj5SZXNvbHV0aW9uPC9zcGFuPg0KICAgICAgPGlucHV0IGlkPSJyZXNvbHV0aW9uIiBuYW1lPSJyZXNvbHV0aW9uIiB0eXBlPSJyYW5nZSIgbWluPSIxIiBtYXg9IjEyOCIgc3RlcD0iMSIgLz4NCiAgICA8L2xhYmVsPg0KDQogICAgPGxhYmVsIGNsYXNzPSJwYXJhbSB0aGluIj4NCiAgICAgIDxzZWxlY3QgaWQ9ImZpbHRlciIgbmFtZT0iZmlsdGVyIj4NCiAgICAgICAgPG9wdGlvbiB2YWx1ZT0iLSI+LTwvb3B0aW9uPg0KICAgICAgICA8b3B0aW9uIHZhbHVlPSJidyI+Qlc8L29wdGlvbj4NCiAgICAgICAgPG9wdGlvbiB2YWx1ZT0iZ3MiPkdTPC9vcHRpb24+DQogICAgICA8L3NlbGVjdD4NCiAgICA8L2xhYmVsPg0KDQogICAgPGxhYmVsIGNsYXNzPSJmaWxlIHRoaW4iPg0KICAgICAgPHNwYW4+VXBsb2FkPC9zcGFuPg0KICAgICAgPGlucHV0IGlkPSJmaWxlcGlja2VyIiBuYW1lPSJmaWxlcGlja2VyIiB0eXBlPSJmaWxlIiAvPg0KICAgIDwvbGFiZWw+DQogIDwvZm9ybT4NCjwvZGl2Pg0K";

    var stylesUrl$4 = "data:text/css;base64,LnJvb3Qgew0KICBwb3NpdGlvbjogcmVsYXRpdmU7DQogIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7DQogIG1pbi1oZWlnaHQ6IDRlbTsNCn0NCg0KY2FudmFzIHsNCiAgd2lkdGg6IDEwMCU7DQogIGltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkOw0KICB0cmFuc2l0aW9uOiBhbGwgMXM7DQp9DQoNCiNjb250cm9sLXBhbmVsIHsNCiAgcG9zaXRpb246IGFic29sdXRlOw0KICB0b3A6IDA7DQogIHJpZ2h0OiAwOw0KICBtYXJnaW46IDFlbTsNCiAgcGFkZGluZzogMC41ZW07DQogIGRpc3BsYXk6IGZsZXg7DQogIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7DQogIGZvbnQtc2l6ZTogMC44cmVtOw0KICBvcGFjaXR5OiAwLjQ7DQogIHRyYW5zaXRpb246IG9wYWNpdHkgMC42czsNCn0NCg0KLnJvb3Q6bm90KC5wYWludGVkKSAjY29udHJvbC1wYW5lbCwNCiNjb250cm9sLXBhbmVsOmhvdmVyIHsNCiAgb3BhY2l0eTogMTsNCn0NCg0KLnJvb3QucGFpbnRlZCAjY29udHJvbC1wYW5lbFtkYXRhLWZpbHRlcj0nYncnXSBsYWJlbC5maWx0ZXIuYncgew0KICBkaXNwbGF5OiBibG9jazsNCn0NCi5yb290LnBhaW50ZWQgI2NvbnRyb2wtcGFuZWxbZGF0YS1maWx0ZXI9J2dzJ10gbGFiZWwuZmlsdGVyLmdzIHsNCiAgZGlzcGxheTogYmxvY2s7DQp9DQoNCi5yb290Om5vdCgucGFpbnRlZCkgY2FudmFzLA0KLnJvb3Q6bm90KC5wYWludGVkKSBsYWJlbC5wYXJhbSwNCmxhYmVsLmZpbHRlciwNCmlucHV0W3R5cGU9J2ZpbGUnXSB7DQogIGRpc3BsYXk6IG5vbmU7DQp9DQoNCmxhYmVsLmZpbGUgew0KICBwYWRkaW5nOiAxZW07DQp9DQpsYWJlbC50aGluIHsNCiAgd2lkdGg6IDNlbTsNCn0NCmxhYmVsIHsNCiAgcG9zaXRpb246IHJlbGF0aXZlOw0KICBkaXNwbGF5OiBibG9jazsNCiAgd2lkdGg6IDVlbTsNCiAgcGFkZGluZzogMCAwLjI1ZW07DQp9DQoNCmxhYmVsID4gc3BhbiB7DQogIHBvc2l0aW9uOiBhYnNvbHV0ZTsNCiAgdG9wOiA1MCU7DQogIGxlZnQ6IDUwJTsNCiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgc2NhbGUoMSwgMik7DQogIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7DQogIHBvaW50ZXItZXZlbnRzOiBub25lOw0KICBmb250LXNpemU6IDAuNWVtOw0KfQ0KDQpsYWJlbC5maWxlID4gc3BhbiB7DQogIGJvcmRlcjogMXB4IHNvbGlkICNhYWE7DQogIGJhY2tncm91bmQtY29sb3I6ICNlZWU7DQogIHBvaW50ZXItZXZlbnRzOiBhbGw7DQogIHBhZGRpbmc6IDAgMC41ZW07DQogIGN1cnNvcjogcG9pbnRlcjsNCn0NCg0KaW5wdXQsDQpzZWxlY3Qgew0KICBmb250OiBpbmhlcml0Ow0KICB3aWR0aDogMTAwJTsNCiAgYm94LXNpemluZzogYm9yZGVyLWJveDsNCn0NCg==";

    class GreyscaleFilter {
        constructor(shades = 16) {
            this.apply = (rgba) => {
                const mean = (rgba[0] + rgba[1] + rgba[2]) / 3;
                const bracketed = range(mean, 0, 255 / this.brackets, 0, 255);
                rgba[3] = 255;
                rgba[0] = rgba[1] = rgba[2] = bracketed;
            };
            this.brackets = range(shades - 1, 16, 1, 1, 255);
        }
    }
    class MonochromeFilter {
        constructor(threshold, inverted, shadeHex) {
            this.threshold = threshold;
            this.inverted = inverted;
            this.apply = (rgba) => {
                const gs = Math.round((rgba[0] + rgba[1] + rgba[2]) / 3);
                if ((this.inverted && gs >= this.threshold) || (!this.inverted && gs < this.threshold)) {
                    rgba[0] = this.shade.r;
                    rgba[1] = this.shade.g;
                    rgba[2] = this.shade.b;
                    rgba[3] = this.shade.a;
                }
                else {
                    rgba[0] = rgba[1] = rgba[2] = rgba[3] = 255;
                }
            };
            const groups = MonochromeFilter.HEX_REG.exec(shadeHex).groups;
            this.shade = {
                r: parseInt(groups.r, 16),
                g: parseInt(groups.g, 16),
                b: parseInt(groups.b, 16),
                a: 255,
            };
        }
    }
    MonochromeFilter.HEX_REG = /^#(?<r>[0-9a-f]{2})(?<g>[0-9a-f]{2})(?<b>[0-9a-f]{2})$/i;
    function range(n, df, to, mn, mx) {
        const rnd = to * Math.round((isNaN(n) ? df : n) / to);
        return Math.max(mn, Math.min(mx, rnd));
    }

    class Pxl8r extends CustomElementBase {
        constructor() {
            super(Pxl8r.Css, Pxl8r.Html);
            this._reader = new FileReader();
            this._original = new Image();
            this._elemCanvas = this.root.querySelector('#canvas');
            this._context = this._elemCanvas.getContext('2d');
            this._context.imageSmoothingEnabled = false;
            this._original.addEventListener('load', () => this.onImageLoad());
            this._reader.addEventListener('load', (e) => (this._original.src = e.target.result));
            this._ctrlForm = this.root.querySelector('#control-panel');
            this._ctrlForm.querySelectorAll('label.filter').forEach((fCtrl) => {
                fCtrl.addEventListener('input', () => this.onFilterChange());
            });
            const elemPicker = this._ctrlForm.filepicker;
            elemPicker.addEventListener('change', () => {
                const file = elemPicker.files[0];
                if (file) {
                    this._reader.readAsDataURL(file);
                    this.removeAttribute('src');
                    elemPicker.value = null;
                }
            });
            const elemResolution = this._ctrlForm.resolution;
            elemResolution.addEventListener('input', (e) => (this.resolution = parseInt(elemResolution.value)));
            const elemFilter = this._ctrlForm.filter;
            elemFilter.addEventListener('change', (e) => (this.filter = elemFilter.value));
        }
        get _configFilter() {
            switch (this.filter) {
                case 'bw':
                    return new MonochromeFilter(this._ctrlForm.threshold.value, this._ctrlForm.invert.checked, this._ctrlForm.shade.value);
                case 'gs':
                    return new GreyscaleFilter(this._ctrlForm.shades.value);
            }
        }
        set src(value) {
            if (value)
                this.setAttribute('src', value);
            else
                this.removeAttribute('src');
        }
        /** The current filter type. */
        get filter() {
            return this._ctrlForm.filter.value;
        }
        set filter(value) {
            if (['bw', 'gs'].indexOf(value) !== -1) {
                this.setAttribute('filter', value);
            }
            else {
                this._ctrlForm.removeAttribute('data-filter');
                this.removeAttribute('filter');
            }
        }
        /** The current resolution value. */
        get resolution() {
            return this._ctrlForm.resolution.value;
        }
        set resolution(value) {
            this.setAttribute('resolution', `${value}`);
        }
        attributeChangedCallback(name, oldValue, newValue) {
            switch (name) {
                case 'src':
                    this._ctrlForm.filepicker.value = null;
                    this._original.src = newValue;
                    break;
                case 'filter':
                    this._ctrlForm.filter.value = newValue || '-';
                    this._ctrlForm.setAttribute('data-filter', newValue || '-');
                    this.onFilterChange();
                    break;
                case 'resolution':
                    const val = parseInt(newValue) || 50;
                    this._ctrlForm.resolution.value = `${Math.max(0, Math.min(val, 128))}`;
                    this.onDimsChange();
                    break;
            }
        }
        connectedCallback() {
            //this.fire('change', this._ctrlForm.filter);
        }
        /** Adds a custom layer, providing its dimensions match the current image. */
        overlay(image) {
            if (this._workingData) {
                const wDims = `${this._workingData.width}x${this._workingData.height}`;
                const iDims = `${image.width}x${image.height}`;
                if (iDims !== wDims)
                    throw new RangeError(`Dimension mismatch. Expected: ${wDims} Received: ${iDims}`);
                this._context.putImageData(image, 0, 0);
            }
        }
        onImageLoad() {
            this.onDimsChange();
        }
        onDimsChange() {
            if (this._original.src) {
                const aspect = this._original.width / this._original.height;
                const x = (this._elemCanvas.width = this.resolution);
                const y = (this._elemCanvas.height = Math.ceil(x / aspect));
                this._context.drawImage(this._original, 0, 0, x, y);
                this._dimensionData = this._context.getImageData(0, 0, x, y);
                this.onFilterChange();
            }
        }
        onFilterChange() {
            if (this._dimensionData) {
                this._workingData = new ImageData(this._dimensionData.data.slice(), this._dimensionData.width, this._dimensionData.height);
                this.applyFilter(this._workingData);
                this.onPaintPixels();
            }
        }
        applyFilter(arr) {
            const filter = this._configFilter;
            if (filter) {
                for (let i = 3; i < arr.data.length; i += 4) {
                    const rgba = arr.data.slice(i - 3, i + 1);
                    filter.apply(rgba);
                    arr.data[i - 3] = rgba[0];
                    arr.data[i - 2] = rgba[1];
                    arr.data[i - 1] = rgba[2];
                    arr.data[i] = rgba[3];
                }
            }
        }
        onPaintPixels() {
            this._context.putImageData(this._workingData, 0, 0);
            this._elemCanvas.closest('.root').classList.add('painted');
            this.fire('render', this, this._workingData);
        }
        /** Emits a new event. */
        fire(event, target, detail) {
            (target || this).dispatchEvent(new CustomEvent(event, { detail }));
        }
    }
    Pxl8r.observedAttributes = ['src', 'filter', 'resolution'];
    Pxl8r.Css = reduceCss(decode(stylesUrl$4));
    Pxl8r.Html = reduceHtml(decode(markupUrl$4));

    if ('customElements' in window) {
        window.customElements.define('ne14-pxl8r', Pxl8r);
    }

    var markupUrl$5 = "data:text/html;base64,PG5lMTQtcHhsOHIgZmlsdGVyPSJidyIgcmVzb2x1dGlvbj0iMzUiPjwvbmUxNC1weGw4cj4NCg==";

    var stylesUrl$5 = "data:text/css;base64,LmJhY2sub3BlbiAuZm9yZSB7DQogIG1pbi13aWR0aDogY2FsYyg1MHZ3KTsNCiAgbWF4LXdpZHRoOiBjYWxjKDEwMHZ3IC0gM2VtKTsNCiAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtIDNlbSk7DQp9DQo=";

    class PixelsPopup extends GriddlerPopupBase {
        constructor() {
            super(markupUrl$5, stylesUrl$5);
            this.validate = () => this.visualTest();
            this.titleText = 'Pixels';
            this.pxl8r = this.$zone
                .first('ne14-pxl8r')
                .on('render', Utils.Debounce((e) => this.onControlRender(e), 100))
                .get(0);
        }
        get labelGrid() {
            return this._labelGrid;
        }
        renderZone() {
            // ...
        }
        onControlRender(event) {
            this.renderData = event.detail;
            this._labelGrid = XGrid.AsPlain(this.renderData);
            XGrid.ScrapeLabels(this._labelGrid);
            XGrid.WipeCells(this._labelGrid);
            this.visualTest();
        }
        visualTest() {
            let retVal = false;
            if (this._labelGrid != null) {
                const result = Grid.load(this._labelGrid).solve();
                retVal = result.solved;
                XGrid.OverlayResult(this.renderData, result);
                this.pxl8r.overlay(this.renderData);
            }
            return retVal;
        }
    }

    var resolution = 2;
    var gridSize = {
    	min: 5,
    	max: 1000,
    	"default": 5,
    	step: 5
    };
    var cellSize = {
    	min: 5,
    	max: 50,
    	"default": 20,
    	step: 1
    };
    var palette = {
    	major: "#bbbbbbff",
    	minor: "#eeeeeeff",
    	label: "#000000ff",
    	cells: "#000000ff"
    };
    var hilite = {
    	"default": "#0000ff33",
    	filling: "#00ff0033",
    	marking: "#ffff0033"
    };

    var markupUrl$6 = "data:text/html;base64,PGRpdiBjbGFzcz0iZ3JpZC16b25lIGRyb3Atem9uZSI+DQogIDxjYW52YXMgaWQ9ImdyaWQiPjwvY2FudmFzPg0KICA8Y2FudmFzIGlkPSJoaWxpdGUiPjwvY2FudmFzPg0KICA8bmUxNC1tZW51IGNsYXNzPSJkYXJrIj4NCiAgICA8bGkgaWQ9ImNlbGwiPg0KICAgICAgPHA+Q2VsbDwvcD4NCiAgICAgIDx1bD48L3VsPg0KICAgIDwvbGk+DQogICAgPGxpIGlkPSJjb2x1bW5zIiBjbGFzcz0ic2V0Ij4NCiAgICAgIDxwPkNvbHVtbjwvcD4NCiAgICAgIDx1bD4NCiAgICAgICAgPGxpIGNsYXNzPSJtYXJrLW91dCI+TWFyayBvdXQ8L2xpPg0KICAgICAgICA8bGkgY2xhc3M9ImZpbGwtb3V0Ij5GaWxsIG91dDwvbGk+DQogICAgICAgIDxsaSBjbGFzcz0ic29sdmUiPlNvbHZlPC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJjbGVhci1zZXQiPkNsZWFyPC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJzcGxpdCI+PC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJsYWJlbHMiPg0KICAgICAgICAgIDxwPkxhYmVsczwvcD4NCiAgICAgICAgICA8dWw+DQogICAgICAgICAgICA8bGkgY2xhc3M9InNwYXduIj5TcGF3bjwvbGk+DQogICAgICAgICAgICA8bGkgY2xhc3M9ImVkaXQiPkVkaXQuLi48L2xpPg0KICAgICAgICAgICAgPGxpIGNsYXNzPSJjbGVhciI+Q2xlYXI8L2xpPg0KICAgICAgICAgIDwvdWw+DQogICAgICAgIDwvbGk+DQogICAgICA8L3VsPg0KICAgIDwvbGk+DQogICAgPGxpIGlkPSJyb3dzIiBjbGFzcz0ic2V0Ij4NCiAgICAgIDxwPlJvdzwvcD4NCiAgICAgIDx1bD4NCiAgICAgICAgPGxpIGNsYXNzPSJtYXJrLW91dCI+TWFyayBvdXQ8L2xpPg0KICAgICAgICA8bGkgY2xhc3M9ImZpbGwtb3V0Ij5GaWxsIG91dDwvbGk+DQogICAgICAgIDxsaSBjbGFzcz0ic29sdmUiPlNvbHZlPC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJjbGVhci1zZXQiPkNsZWFyPC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJzcGxpdCI+PC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJsYWJlbHMiPg0KICAgICAgICAgIDxwPkxhYmVsczwvcD4NCiAgICAgICAgICA8dWw+DQogICAgICAgICAgICA8bGkgY2xhc3M9InNwYXduIj5TcGF3bjwvbGk+DQogICAgICAgICAgICA8bGkgY2xhc3M9ImVkaXQiPkVkaXQuLi48L2xpPg0KICAgICAgICAgICAgPGxpIGNsYXNzPSJjbGVhciI+Q2xlYXI8L2xpPg0KICAgICAgICAgIDwvdWw+DQogICAgICAgIDwvbGk+DQogICAgICA8L3VsPg0KICAgIDwvbGk+DQogICAgPGxpIGlkPSJncmlkIj4NCiAgICAgIDxwPkdyaWQ8L3A+DQogICAgICA8dWw+DQogICAgICAgIDxsaSBjbGFzcz0iaGludCI+SGludDwvbGk+DQogICAgICAgIDxsaSBjbGFzcz0ic29sdmUiPlNvbHZlPC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJjbGVhci1ncmlkIj5DbGVhcjwvbGk+DQogICAgICAgIDxsaSBjbGFzcz0ic3BsaXQiPjwvbGk+DQogICAgICAgIDxsaSBjbGFzcz0ibGFiZWxzIj4NCiAgICAgICAgICA8cD5MYWJlbHM8L3A+DQogICAgICAgICAgPHVsPg0KICAgICAgICAgICAgPGxpIGNsYXNzPSJzcGF3biI+U3Bhd248L2xpPg0KICAgICAgICAgICAgPGxpIGNsYXNzPSJjbGVhciI+Q2xlYXI8L2xpPg0KICAgICAgICAgIDwvdWw+DQogICAgICAgIDwvbGk+DQogICAgICA8L3VsPg0KICAgIDwvbGk+DQogICAgPGxpIGNsYXNzPSJzcGxpdCI+PC9saT4NCiAgICA8bGkgaWQ9ImltcG9ydCI+DQogICAgICA8cD5JbXBvcnQ8L3A+DQogICAgICA8dWw+DQogICAgICAgIDxsaSBjbGFzcz0ianNvbiI+DQogICAgICAgICAgPHA+RmlsZS4uLjwvcD4NCiAgICAgICAgICA8aW5wdXQgdHlwZT0iZmlsZSIgLz4NCiAgICAgICAgPC9saT4NCiAgICAgICAgPGxpIGNsYXNzPSJwaXhlbCI+SW1hZ2UgcGl4ZWxhdG9yLi4uPC9saT4NCiAgICAgIDwvdWw+DQogICAgPC9saT4NCiAgICA8bGkgaWQ9ImV4cG9ydCI+DQogICAgICA8cD5FeHBvcnQ8L3A+DQogICAgICA8dWw+DQogICAgICAgIDxsaSBjbGFzcz0ianNvbiI+QXMgZmlsZTwvbGk+DQogICAgICAgIDxsaSBjbGFzcz0iaW1hZ2UiPkFzIGltYWdlPC9saT4NCiAgICAgICAgPGxpIGFyaWEta2V5c2hvcnRjdXRzPSJDdHJsK1AiIGNsYXNzPSJwcmludCI+UHJpbnQ8L2xpPg0KICAgICAgPC91bD4NCiAgICA8L2xpPg0KICAgIDxsaSBpZD0ic2V0dGluZ3MiPlNldHRpbmdzLi4uPC9saT4NCiAgICA8bGkgY2xhc3M9InNwbGl0Ij48L2xpPg0KICAgIDxsaSBpZD0iY2hhbmdlcyI+DQogICAgICA8cD5BY3Rpb25zPC9wPg0KICAgICAgPHVsPg0KICAgICAgICA8bGkgYXJpYS1rZXlzaG9ydGN1dHM9IkN0cmwrWiIgY2xhc3M9InVuZG8iPlVuZG88L2xpPg0KICAgICAgICA8bGkgYXJpYS1rZXlzaG9ydGN1dHM9IkN0cmwrWSIgY2xhc3M9InJlZG8iPlJlZG88L2xpPg0KICAgICAgICA8bGkgY2xhc3M9Imhpc3RvcnkiPlZpZXcgbG9nLi4uPC9saT4NCiAgICAgIDwvdWw+DQogICAgPC9saT4NCiAgPC9uZTE0LW1lbnU+DQo8L2Rpdj4NCg==";

    var stylesUrl$6 = "data:text/css;base64,LmdyaWQtem9uZSB7DQogIHBvc2l0aW9uOiByZWxhdGl2ZTsNCn0NCg0KY2FudmFzIHsNCiAgd2lkdGg6IDEwMCU7DQp9DQpjYW52YXMjaGlsaXRlIHsNCiAgcG9zaXRpb246IGFic29sdXRlOw0KICB0b3A6IDA7DQogIHJpZ2h0OiAwOw0KICBib3R0b206IDA7DQogIGxlZnQ6IDA7DQogIHBvaW50ZXItZXZlbnRzOiBub25lOw0KfQ0KDQpuZTE0LW1lbnUuZGFyayB7DQogIC0tYmc6ICMzMzM7DQogIC0tYm9yZGVyOiAxcHggc29saWQgIzg4ODsNCiAgLS1ib3gtc2hhZG93OiAycHggMnB4IDNweCAjMzMzOw0KICAtLWhvdmVyLWl0ZW0tYmc6ICM2NjY7DQogIC0tZmc6ICNlZWU7DQogIC0tZGlzYWJsZWQtZmc6ICM2NjY7DQp9DQoNCkBtZWRpYSBwcmludCB7DQogICNoaWxpdGUsDQogIG5lMTQtbWVudSB7DQogICAgZGlzcGxheTogbm9uZTsNCiAgfQ0KfQ0K";

    class Griddler extends CustomElementBase {
        constructor() {
            super(Griddler.Css, Griddler.Html);
            this._settingsPopup = new SettingsPopup();
            this._historyPopup = new HistoryPopup();
            this._editLabelPopup = new EditLabelPopup();
            this._pixelsPopup = new PixelsPopup();
            this._size = cellSize.default * resolution;
            this._grid = XGrid.AsPlain({ x: gridSize.default, y: gridSize.default });
            this._history = [];
            this._historyIndex = 0;
            this._fontSize = this._size * 0.55;
            this.$root = q(this.root);
            this.$menu = this.$root.first('ne14-menu');
            this.handleMenuEvents();
            this.$grid = this.$root.first('canvas#grid');
            this._ctxGrid = this.$grid.get(0).getContext('2d');
            this._ctxGrid.imageSmoothingEnabled = false;
            this.$lite = this.$root.first('canvas#hilite');
            this._ctxLite = this.$lite.get(0).getContext('2d');
            this._ctxLite.imageSmoothingEnabled = false;
            this.$grid.on('mouseleave', () => {
                if (!this._downCoords)
                    this.clearContext(this._ctxLite);
            });
            this.$grid.on('mousemove', (e) => {
                var _a, _b;
                const moveCoords = this.getCoords(e);
                this.highlight(!this._downCoords ? moveCoords : null);
                // Check for dragging on initiating sets
                const isColDrag = ((_a = this._downCoords) === null || _a === void 0 ? void 0 : _a.x) === moveCoords.x;
                const isRowDrag = ((_b = this._downCoords) === null || _b === void 0 ? void 0 : _b.y) === moveCoords.y;
                // If ripe for the paintin'
                if ((isColDrag || isRowDrag) && moveCoords.state === 0) {
                    // Use initial state (or 0 -> 1 fill blanks)
                    this.setState(moveCoords, this._downCoords.state || 1);
                }
            });
            this.$grid.on('mousedown', (e) => {
                const coords = this.getCoords(e, true);
                if (e.which === 3) {
                    this._menuCoords = coords;
                    this.updateMenuContext();
                }
                else {
                    this._downCoords = coords;
                    this.highlight();
                }
            });
            this.$grid.on('mouseup', (e) => {
                e.stopImmediatePropagation();
                const upCoords = this.getCoords(e);
                this.highlight(upCoords);
                if (this._downCoords) {
                    if (upCoords.x === this._downCoords.x && upCoords.y === this._downCoords.y) {
                        if (upCoords.x != null && upCoords.y != null) {
                            // cell
                            let state;
                            switch (this._downCoords.which) {
                                case 'left':
                                    state = ((this._downCoords.state + 1) % 3);
                                    break;
                                case 'right':
                                    state = this._downCoords.state === 2 ? 0 : 2;
                                    break;
                            }
                            this.setState(this._downCoords, state);
                        }
                        else if (upCoords.x != null)
                            this.showLabelModal('columns', upCoords.x);
                        else if (upCoords.y != null)
                            this.showLabelModal('rows', upCoords.y);
                    }
                    if (this._downCoords.pending) {
                        this.addToHistory('paint', this._downCoords.snapshot);
                    }
                    this._downCoords = null;
                }
            });
            q(window).on('mouseup', () => {
                this._downCoords = null;
                this.clearContext(this._ctxLite);
            });
            this.$root.find('.drop-zone').on('dragover', (event) => event.preventDefault());
            this.$root.find('.drop-zone').on('drop', (event) => {
                event.preventDefault();
                this.read(event.dataTransfer.files[0]);
            });
            this.$root
                .appendIn(this._settingsPopup)
                .on('confirmaccept', () => console.log('handle settings change!'));
            this.$root
                .appendIn(this._historyPopup)
                .on('confirmaccept', () => console.log('handle history change!'));
            this.$root.appendIn(this._editLabelPopup).on('confirmaccept', () => this.receiveLabelUpdate());
            this.$root.appendIn(this._pixelsPopup).on('confirmaccept', () => {
                const prevGrid = this.toString();
                this.load(this._pixelsPopup.labelGrid);
                if (this.toString() !== prevGrid) {
                    this.addToHistory('pixels', prevGrid);
                }
            });
        }
        get totalColumns() {
            return this._grid.columns.length;
        }
        get totalRows() {
            return this._grid.rows.length;
        }
        get totalWidth() {
            return this.$grid.elements[0].width;
        }
        set totalWidth(value) {
            this.$grid.prop('width', value);
            this.$lite.prop('width', value);
        }
        get totalHeight() {
            return this.$grid.elements[0].height;
        }
        set totalHeight(value) {
            this.$grid.prop('height', value);
            this.$lite.prop('height', value);
        }
        get isBlank() {
            return !this._grid.rows.some((r) => r.cells && /[12]/.test(r.cells + ''));
        }
        get isFull() {
            return this._grid.rows.every((r) => /^[12,]+$/.test(r.cells + ''));
        }
        get anyLabels() {
            return (this._grid.rows.some((r) => { var _a; return (_a = r.labels) === null || _a === void 0 ? void 0 : _a.length; }) ||
                this._grid.columns.some((c) => { var _a; return (_a = c.labels) === null || _a === void 0 ? void 0 : _a.length; }));
        }
        toString() {
            return JSON.stringify(XGrid.ToDense(this._grid));
        }
        get textDataUrl() {
            const encoded = window.encodeURIComponent(this.toString());
            return `data:text/plain;charset=utf-8,${encoded}`;
        }
        get imageDataUrl() {
            return this.$grid.get(0).toDataURL();
        }
        /**
         * Draws a grid according to the grid data supplied.
         * @param grid The grid data.
         */
        load(grid) {
            this._grid = XGrid.AsPlain(grid);
            this.refresh();
        }
        /** Removes all cell data, leaving the labels intact. */
        clear() {
            if (!this.isBlank) {
                this.addToHistory('clear-grid', this.toString());
                XGrid.WipeCells(this._grid);
                this.refresh();
            }
        }
        /** Provides a hint for the next solving action. */
        hint() {
            const result = Grid.load(this._grid).nextHint();
            console.log(result);
        }
        /** Attempts to solve the grid. */
        solve() {
            if (!this.isFull) {
                const result = Grid.load(this._grid).solve();
                if (result.solved) {
                    console.log('Solved in ' + result.solvedMs + 'ms');
                    this.addToHistory('solve', this.toString());
                    this.load(result.grid);
                }
            }
        }
        /**
         * Redraws the entire grid in accordance with the current state.
         */
        refresh() {
            const grid_w = this.totalColumns * this._size + Griddler.PIXEL_OFFSET;
            const grid_h = this.totalRows * this._size + Griddler.PIXEL_OFFSET;
            const labels_w = Math.max(this._size * 2, (grid_w * 2) / 5);
            const labels_h = Math.max(this._size * 2, (grid_h * 2) / 5);
            this.totalWidth = grid_w + labels_w;
            this.totalHeight = grid_h + labels_h;
            const client_w = this.totalWidth / resolution;
            this.root.querySelector('.grid-zone').setAttribute('style', `width: ${client_w}px`);
            this.clearContext(this._ctxGrid);
            this._ctxGrid.fillStyle = '#fff';
            this._ctxGrid.fillRect(0, 0, this.totalWidth, this.totalHeight);
            this._ctxGrid.beginPath();
            for (let c = 0; c <= this.totalColumns; c++) {
                this._ctxGrid.moveTo(c * this._size + Griddler.PIXEL_OFFSET, 0);
                this._ctxGrid.lineTo(c * this._size + Griddler.PIXEL_OFFSET, grid_h);
            }
            for (let r = 0; r <= this.totalRows; r++) {
                this._ctxGrid.moveTo(0, r * this._size + Griddler.PIXEL_OFFSET);
                this._ctxGrid.lineTo(grid_w, r * this._size + Griddler.PIXEL_OFFSET);
            }
            this._ctxGrid.strokeStyle = palette.minor;
            this._ctxGrid.lineWidth = resolution;
            this._ctxGrid.stroke();
            this._ctxGrid.closePath();
            this._ctxGrid.beginPath();
            for (let c = 0; c <= this.totalColumns; c += gridSize.step) {
                this._ctxGrid.moveTo(c * this._size + Griddler.PIXEL_OFFSET, 0);
                this._ctxGrid.lineTo(c * this._size + Griddler.PIXEL_OFFSET, grid_h);
            }
            for (let r = 0; r <= this.totalRows; r += gridSize.step) {
                this._ctxGrid.moveTo(0, r * this._size + Griddler.PIXEL_OFFSET);
                this._ctxGrid.lineTo(grid_w, r * this._size + Griddler.PIXEL_OFFSET);
            }
            this._ctxGrid.strokeStyle = palette.major;
            this._ctxGrid.lineWidth = resolution;
            this._ctxGrid.stroke();
            this._ctxGrid.closePath();
            this.populate();
        }
        connectedCallback() {
            this.refresh();
        }
        attributeChangedCallback(name, oldValue, newValue) {
            switch (name) {
                case 'cols':
                    const totalColumns = Griddler.Round(newValue, gridSize.default, gridSize.step, gridSize.min, gridSize.max);
                    this.load(XGrid.AsPlain({ x: totalColumns, y: this.totalRows }));
                    break;
                case 'rows':
                    const totalRows = Griddler.Round(newValue, gridSize.default, gridSize.step, gridSize.min, gridSize.max);
                    this.load(XGrid.AsPlain({ x: this.totalColumns, y: totalRows }));
                    break;
                case 'size':
                    this._size = Griddler.Round(newValue, cellSize.default * resolution, cellSize.step * resolution, cellSize.min * resolution, cellSize.max * resolution);
                    break;
            }
        }
        static Download(dataUrl, filename) {
            const tempLink = document.createElement('a');
            tempLink.href = dataUrl;
            tempLink.download = filename;
            tempLink.click();
        }
        static Round(val, def, to, min, max) {
            val = parseInt(`${val}`);
            const rnd = to * Math.round((isNaN(val) ? def : val) / to);
            return Math.max(min, Math.min(max, rnd));
        }
        read(file) {
            if (file == null)
                return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const current = this.toString();
                const loaded = e.target.result;
                if (loaded !== current) {
                    this.load(JSON.parse(loaded));
                    this.addToHistory('load', current);
                }
            };
            reader.readAsText(file);
        }
        addToHistory(type, grid) {
            this._history.splice(this._historyIndex);
            this._historyIndex = this._history.push({
                date: new Date(),
                type,
                grid,
            });
        }
        gotoHistory(newIndex) {
            if (newIndex === this._historyIndex)
                return;
            const historyItem = this._history[newIndex];
            if (historyItem) {
                this._historyIndex = newIndex;
                this.load(JSON.parse(historyItem.grid));
            }
        }
        undoOne() {
            var _a;
            if (this._historyIndex === this._history.length) {
                const curr = this.toString();
                if (curr !== ((_a = this._history[this._historyIndex]) === null || _a === void 0 ? void 0 : _a.grid)) {
                    this.addToHistory('undo', curr);
                    this._historyIndex--;
                }
            }
            this.gotoHistory(this._historyIndex - 1);
        }
        getState(point) {
            return point.x == null || point.y == null ? null : this._grid.rows[point.y].cells[point.x];
        }
        setState(point, state) {
            var _a;
            if (point.x != null && point.y != null) {
                const celRef = this._grid.rows[point.y].cells;
                if (celRef[point.x] !== state) {
                    celRef[point.x] = state;
                    this._ctxGrid.beginPath();
                    this.setCell(point.x, point.y);
                    this._ctxGrid.fillStyle = '#fff';
                    this._ctxGrid.fill();
                    this._ctxGrid.beginPath();
                    switch (state) {
                        case 1:
                            this.setCell(point.x, point.y);
                            break;
                        case 2:
                            this.markCell(point.x, point.y);
                            break;
                    }
                    this._ctxGrid.fillStyle = palette.cells;
                    this._ctxGrid.fill();
                    if ((_a = this._downCoords) === null || _a === void 0 ? void 0 : _a.snapshot) {
                        this._downCoords.pending = true;
                    }
                }
            }
        }
        markCell(ci, ri) {
            const x0 = ci * this._size + Griddler.PIXEL_OFFSET + this._size / 2;
            const y0 = ri * this._size + Griddler.PIXEL_OFFSET + this._size / 2;
            this._ctxGrid.moveTo(x0, y0);
            this._ctxGrid.arc(x0, y0, this._size / 8, 0, 2 * Math.PI);
        }
        setCell(ci, ri) {
            const buffer = 2 * Griddler.PIXEL_OFFSET;
            this._ctxGrid.rect(ci * this._size + buffer, ri * this._size + buffer, this._size - buffer, this._size - buffer);
        }
        populate() {
            this.populateLabels();
            this.populateStates();
        }
        populateLabels() {
            this._ctxGrid.font = `${this._fontSize}px Times New Roman`;
            this._ctxGrid.fillStyle = palette.label;
            const grid_w = this.totalColumns * this._size + Griddler.PIXEL_OFFSET;
            this._ctxGrid.clearRect(grid_w, 0, this.totalWidth, this.totalHeight);
            this._grid.rows
                .map((row, idx) => ({ labels: row.labels, idx }))
                .filter((set) => set.labels && set.labels.length > 0)
                .forEach((set) => this.setRowLabels(set.idx, set.labels, grid_w));
            const grid_h = this.totalRows * this._size + Griddler.PIXEL_OFFSET;
            this._ctxGrid.clearRect(0, grid_h, this.totalWidth, this.totalHeight);
            this._grid.columns
                .map((col, idx) => ({ labels: col.labels, idx }))
                .filter((set) => set.labels && set.labels.length > 0)
                .forEach((set) => this.setColumnLabels(set.idx, set.labels, grid_h));
        }
        populateStates() {
            this._ctxGrid.beginPath();
            this._grid.rows
                .map((row, idx) => ({ cells: row.cells, idx }))
                .forEach((row) => (row.cells || [])
                .map((state, idx) => ({ state, idx }))
                .forEach((cell) => {
                switch (cell.state) {
                    case 1:
                        this.setCell(cell.idx, row.idx);
                        break;
                    case 2:
                        this.markCell(cell.idx, row.idx);
                        break;
                }
            }));
            this._ctxGrid.fillStyle = palette.cells;
            this._ctxGrid.fill();
        }
        setRowLabels(idx, labels, grid_w) {
            const isBulk = !!grid_w;
            grid_w = grid_w || this.totalColumns * this._size + Griddler.PIXEL_OFFSET;
            const x = grid_w + this._fontSize / 2;
            const y = idx * this._size + this._size / 2 + this._fontSize / 2;
            this._ctxGrid.textAlign = 'left';
            if (!isBulk)
                this._ctxGrid.clearRect(x, idx * this._size, this.totalWidth, this._size);
            this._ctxGrid.fillText(labels.join(' . '), x, y);
        }
        setColumnLabels(idx, labels, grid_h) {
            const isBulk = !!grid_h;
            grid_h = grid_h || this.totalRows * this._size + Griddler.PIXEL_OFFSET;
            const x = idx * this._size + this._size / 2 + 2;
            this._ctxGrid.textAlign = 'center';
            if (!isBulk)
                this._ctxGrid.clearRect(idx * this._size, grid_h, this._size, this.totalHeight);
            labels.forEach((label, idx) => {
                this._ctxGrid.fillText(label + '', x, grid_h + this._fontSize * 1.2 * (idx + 1.2));
            });
        }
        clearContext(context) {
            context.clearRect(0, 0, this.totalWidth, this.totalHeight);
        }
        getCoords(locator, snapshot = false) {
            const ci = Griddler.Round((locator.offsetX * resolution) / this._size, 0, 1, 0, this.totalColumns);
            const ri = Griddler.Round((locator.offsetY * resolution) / this._size, 0, 1, 0, this.totalRows);
            const dims = {
                x: ci === this.totalColumns ? null : ci,
                y: ri === this.totalRows ? null : ri,
            };
            return Object.assign(Object.assign({}, dims), { x0: dims.x * this._size + Griddler.PIXEL_OFFSET, y0: dims.y * this._size + Griddler.PIXEL_OFFSET, which: locator.which === 1 ? 'left' : locator.which === 0 ? null : 'right', state: this.getState(dims), snapshot: snapshot ? this.toString() : null });
        }
        getShade(state) {
            switch (state) {
                case -1:
                    return hilite.default;
                case 2:
                    return hilite.marking;
                default:
                    return hilite.filling;
            }
        }
        highlight(coords) {
            var _a;
            this.clearContext(this._ctxLite);
            const state = coords ? -1 : ((_a = this._downCoords) === null || _a === void 0 ? void 0 : _a.which) === 'left' ? 1 : 2;
            this._ctxLite.fillStyle = this.getShade(state);
            coords = coords !== null && coords !== void 0 ? coords : this._downCoords;
            if (coords.x != null)
                this._ctxLite.fillRect(coords.x0, 0, this._size, this.totalHeight);
            if (coords.y != null)
                this._ctxLite.fillRect(0, coords.y0, this.totalWidth, this._size);
            if (coords.x != null && coords.y != null) {
                const buffer = 2 * Griddler.PIXEL_OFFSET;
                this._ctxLite.clearRect(coords.x0 + buffer, coords.y0 + buffer, this._size - 2 * buffer, this._size - 2 * buffer);
            }
        }
        showHistoryModal() {
            this._historyPopup.historyItems = this._history;
            this._historyPopup.historyIndex = this._historyIndex;
            this._historyPopup.open();
        }
        showLabelModal(type, index) {
            this._editLabelPopup.setType = type;
            this._editLabelPopup.setIndex = index;
            this._editLabelPopup.capacity = this._grid[type === 'rows' ? 'columns' : 'rows'].length;
            this._editLabelPopup.labels = this._grid[type][index].labels;
            this._editLabelPopup.open();
        }
        receiveLabelUpdate() {
            const type = this._editLabelPopup.setType;
            const index = this._editLabelPopup.setIndex;
            const set = this._grid[type][index];
            const next = this._editLabelPopup.labels;
            if (next.join(',') !== set.labels.join(',')) {
                this.addToHistory('label', this.toString());
                set.labels = next;
                if (type === 'rows')
                    this.setRowLabels(index, next);
                else
                    this.setColumnLabels(index, next);
            }
        }
        handleMenuEvents() {
            this.$menu.on('menuopen', () => setTimeout(() => this.highlight(this._menuCoords)));
            this.$menu.on('mouseup', (e) => e.stopPropagation());
            this.$menu.on('mouseleave', () => this.clearContext(this._ctxLite));
            this.$menu.on('itemhover', (e) => {
                const setNode = e.detail.origin.closest('li.set[id]');
                if (setNode && setNode.classList.contains('set')) {
                    const coordsClone = JSON.parse(JSON.stringify(this._menuCoords));
                    const setType = setNode.id;
                    if (setType == 'rows')
                        delete coordsClone.x;
                    else
                        delete coordsClone.y;
                    this.highlight(coordsClone);
                }
                else {
                    this.highlight(this._menuCoords);
                }
            });
            // Handler for methods sensitive to the cell reference
            this.$menu.on('itemselect', (e) => {
                const item = e.detail.origin;
                if (item.matches('.set li')) {
                    const setType = item.closest('.set').id;
                    const setIndex = setType == 'rows' ? this._menuCoords.y : this._menuCoords.x;
                    if (item.matches('.mark-out')) ;
                    else if (item.matches('.fill-out')) ;
                    else if (item.matches('.solve')) ;
                    else if (item.matches('.clear-set')) ;
                    else if (item.matches('.labels .spawn')) ;
                    else if (item.matches('.labels .edit')) {
                        this.showLabelModal(setType, setIndex);
                    }
                    else if (item.matches('.labels .clear')) {
                        const set = this._grid[setType][setIndex];
                        const empty = [];
                        if (empty.join(',') !== set.labels.join(',')) {
                            this.addToHistory('label', this.toString());
                            set.labels = empty;
                            if (setType === 'rows')
                                this.setRowLabels(setIndex, empty);
                            else
                                this.setColumnLabels(setIndex, empty);
                        }
                    }
                }
            });
            this.$menu.find('#changes .undo').on('click', () => this.undoOne());
            this.$menu.find('#changes .redo').on('click', () => this.gotoHistory(this._historyIndex + 1));
            this.$menu.find('#changes .history').on('click', () => this.showHistoryModal());
            this.$menu.find('#grid .hint').on('click', () => this.hint());
            this.$menu.find('#grid .solve').on('click', () => this.solve());
            this.$menu.find('#grid .clear-grid').on('click', () => this.clear());
            this.$menu.find('#grid .labels .spawn').on('click', () => {
                XGrid.ScrapeLabels(this._grid);
                this.populateLabels();
                if (this._menuCoords.snapshot !== this.toString()) {
                    this.addToHistory('spawn', this._menuCoords.snapshot);
                }
            });
            this.$menu.find('#grid .labels .clear').on('click', () => {
                XGrid.WipeLabels(this._grid);
                this.populateLabels();
                if (this._menuCoords.snapshot !== this.toString()) {
                    this.addToHistory('clear-labels', this._menuCoords.snapshot);
                }
            });
            const fileElem = this.$menu.find('#import .json > [type=file]').get(0);
            this.$menu.find('#import .json').on('click', () => fileElem.click());
            this.$menu.find('#import .pixel').on('click', () => this._pixelsPopup.open());
            this.$menu
                .find('#export .json')
                .on('click', () => Griddler.Download(this.textDataUrl, 'grid.json'));
            this.$menu
                .find('#export .image')
                .on('click', () => Griddler.Download(this.imageDataUrl, 'grid.png'));
            this.$menu.find('#export .print').on('click', () => window.print());
            this.$menu.find('#settings').on('click', () => this._settingsPopup.open());
        }
        updateMenuContext() {
            var _a;
            const coords = this._menuCoords;
            this.$menu
                .first('#columns')
                .toggle('hidden', coords.x == null)
                .first('p')
                .empty()
                .append(`<span>Column ${coords.x + 1}</span>`);
            this.$menu
                .first('#rows')
                .toggle('hidden', coords.y == null)
                .first('p')
                .empty()
                .append(`<span>Row ${coords.y + 1}</span>`);
            this.$menu
                .first('#cell')
                .toggle('hidden', coords.x == null || coords.y == null)
                .first('p')
                .empty()
                .append(`<span>Cell (${coords.x + 1}, ${coords.y + 1})</span>`);
            this.$menu.first('#changes .undo').toggle('disabled', this._historyIndex <= 0);
            this.$menu
                .first('#changes .redo')
                .toggle('disabled', this._historyIndex >= this._history.length - 1);
            this.$menu.first('#changes .history').toggle('disabled', !((_a = this._history) === null || _a === void 0 ? void 0 : _a.length));
            this.$menu.first('#changes').toggle('disabled', (e) => !e.querySelector('li:not(.disabled)'));
            this.$menu.first('#grid .hint').toggle('disabled', this.isFull);
            this.$menu.first('#grid .solve').toggle('disabled', this.isFull);
            this.$menu.first('#grid .clear-grid').toggle('disabled', this.isBlank);
            this.$menu.first('#grid .labels .spawn').toggle('disabled', this.isBlank);
            this.$menu.first('#grid .labels .clear').toggle('disabled', !this.anyLabels);
            this.$menu.find('.set .labels .clear').toggle('disabled', (e) => {
                var _a;
                const set = e.closest('.set').id == 'rows' ? this._grid.rows[coords.y] : this._grid.columns[coords.x];
                return !((_a = set === null || set === void 0 ? void 0 : set.labels) === null || _a === void 0 ? void 0 : _a.length);
            });
            // Reload for changes into shadow DOM
            this.$menu.get(0).reload();
        }
    }
    Griddler.observedAttributes = ['cols', 'rows', 'size'];
    Griddler.Css = reduceCss(decode(stylesUrl$6));
    Griddler.Html = reduceHtml(decode(markupUrl$6));
    Griddler.PIXEL_OFFSET = resolution / 2;

    if ('customElements' in window) {
        window.customElements.define('ne14-grid-pop-settings', SettingsPopup);
        window.customElements.define('ne14-grid-pop-history', HistoryPopup);
        window.customElements.define('ne14-grid-pop-edit-label', EditLabelPopup);
        window.customElements.define('ne14-grid-pop-pixels', PixelsPopup);
        window.customElements.define('ne14-grid', Griddler);
    }

    exports.Griddler = Griddler;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
